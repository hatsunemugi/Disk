# Redis configuration file example. # # Note that in order to read the configuration file, Redis must be # started with the file path as first argument: # # ./redis-server /path/to/redis.conf
# Redis 配置文件示例。# # 请注意，为了读取配置文件，Redis 必须 # 以文件路径作为第一个参数启动：# # ./redis-server /path/to/redis.conf

# Note on units: when memory size is needed, it is possible to specify # it in the usual form of 1k 5GB 4M and so forth: # # 1k => 1000 bytes # 1kb => 1024 bytes # 1m => 1000000 bytes # 1mb => 1024*1024 bytes # 1g => 1000000000 bytes # 1gb => 1024*1024*1024 bytes # # units are case insensitive so 1GB 1Gb 1gB are all the same.
＃关于单位的说明：当需要内存大小时，可以以 1k 5GB 4M 等常见形式指定它：＃＃ 1k => 1000 字节＃ 1kb => 1024 字节＃ 1m => 1000000 字节＃ 1mb => 1024*1024 字节＃ 1g => 1000000000 字节＃ 1gb => 1024*1024*1024 字节＃＃单位不区分大小写，因此 1GB 1Gb 1gB 都是相同的。

################################## INCLUDES ###################################
包含以下内容：##################################

# Include one or more other config files here. This is useful if you # have a standard template that goes to all Redis servers but also need # to customize a few per-server settings. Include files can include # other files, so use this wisely. # # Note that option "include" won't be rewritten by command "CONFIG REWRITE" # from admin or Redis Sentinel. Since Redis always uses the last processed # line as value of a configuration directive, you'd better put includes # at the beginning of this file to avoid overwriting config change at runtime. # # If instead you are interested in using includes to override configuration # options, it is better to use include as the last line. # # Included paths may contain wildcards. All files matching the wildcards will # be included in alphabetical order. # Note that if an include path contains a wildcards but no files match it when # the server is started, the include statement will be ignored and no error will # be emitted. It is safe, therefore, to include wildcard files from empty # directories. # # include /path/to/local.conf # include /path/to/other.conf # include /path/to/fragments/*.conf #
＃在这里包含一个或多个其他配置文件。如果您有一个适用于所有 Redis 服务器的标准模板，但也需要自定义一些每个服务器的设置，则这将非常有用。包含文件可以包含其他文件，因此请明智地使用此功能。＃请注意，选项“include”不会被管理员或 Redis Sentinel 的“CONFIG REWRITE”命令重写。由于 Redis 始终使用最后处理的行作为配置指令的值，因此最好将包含放在此文件的开头，以避免在运行时覆盖配置更改。＃如果您希望使用包含来覆盖配置选项，最好将 include 用作最后一行。＃包含的路径可能包含通配符。所有匹配通配符的文件将按字母顺序包含。请注意，如果包含路径包含通配符，但在启动服务器时没有文件与之匹配，则将忽略包含语句并且不会发出错误。因此，可以安全地从空目录包含通配符文件。＃包括/path/to/local.conf＃包括/path/to/other.conf＃包括/path/to/fragments/*.conf＃

################################## MODULES #####################################
################################## 模块 #####################################

# Load modules at startup. If the server is not able to load modules # it will abort. It is possible to use multiple loadmodule directives. # # loadmodule /path/to/my_module.so # loadmodule /path/to/other_module.so # loadmodule /path/to/args_module.so [arg [arg ...]]
# 在启动时加载模块。如果服务器无法加载模块，它将中止。可以使用多个 loadmodule 指令。 # # loadmodule /path/to/my_module.so # loadmodule /path/to/other_module.so # loadmodule /path/to/args_module.so [arg [arg ...]]

################################## NETWORK #####################################
################################## 网络 #####################################

# By default, if no "bind" configuration directive is specified, Redis listens # for connections from all available network interfaces on the host machine. # It is possible to listen to just one or multiple selected interfaces using # the "bind" configuration directive, followed by one or more IP addresses. # Each address can be prefixed by "-", which means that redis will not fail to # start if the address is not available. Being not available only refers to # addresses that does not correspond to any network interface. Addresses that # are already in use will always fail, and unsupported protocols will always BE # silently skipped. # # Examples: # # bind 192.168.1.100 10.0.0.1 # listens on two specific IPv4 addresses # bind 127.0.0.1 ::1 # listens on loopback IPv4 and IPv6 # bind * -::* # like the default, all available interfaces # # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the # internet, binding to all the interfaces is dangerous and will expose the # instance to everybody on the internet. So by default we uncomment the # following bind directive, that will force Redis to listen only on the # IPv4 and IPv6 (if available) loopback interface addresses (this means Redis # will only be able to accept client connections from the same host that it is # running on). # # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES # COMMENT OUT THE FOLLOWING LINE. # # You will also need to set a password unless you explicitly disable protected # mode. # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ bind 127.0.0.1 -::1
# 默认情况下，如果未指定“bind”配置指令，则 Redis 会监听主机上所有可用网络接口的连接。# 可以使用“bind”配置指令来仅监听一个或多个选定的接口，后跟一个或多个 IP 地址。# 每个地址都可以以“-”为前缀，这意味着如果地址不可用，Redis 不会启动失败。不可用仅指不对应任何网络接口的地址。已在使用中的地址将始终失败，并且不支持的协议将始终被静默跳过。# # 示例：# # bind 192.168.1.100 10.0.0.1 # 监听两个特定的 IPv4 地址# bind 127.0.0.1 ::1 # 监听回环 IPv4 和 IPv6# bind * -::* # 像默认情况一样，所有可用接口# # ~~~ 警告 ~~~ 如果运行 Redis 的计算机直接暴露在互联网上，则绑定到所有接口是危险的，并且会使实例暴露给互联网上的所有人。 因此，默认情况下，我们取消注释绑定指令后面的＃，这将强制 Redis 仅在 IPv4 和 IPv6（如果可用）环回接口地址上侦听（这意味着 Redis 将只能接受来自运行在同一主机上的客户端连接）。 # # 如果您确定要使您的实例侦听所有接口，请注释掉以下行。 # # 除非显式禁用受保护模式，否则还需要设置密码。 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ bind 127.0.0.1 -::1

# By default, outgoing connections (from replica to master, from Sentinel to # instances, cluster bus, etc.) are not bound to a specific local address. In # most cases, this means the operating system will handle that based on routing # and the interface through which the connection goes out. # # Using bind-source-addr it is possible to configure a specific address to bind # to, which may also affect how the connection gets routed. # # Example: # # bind-source-addr 10.0.0.1
# 默认情况下，出站连接（从副本到主服务器，从 Sentinel 到实例，集群总线等）不绑定到特定的本地地址。在大多数情况下，这意味着操作系统将根据路由和连接传输的接口来处理。# # 使用 bind-source-addr 可以配置一个特定的地址来绑定，这也可能影响连接的路由方式。# # 示例：# # bind-source-addr 10.0.0.1

# Protected mode is a layer of security protection, in order to avoid that # Redis instances left open on the internet are accessed and exploited. # # When protected mode is on and the default user has no password, the server # only accepts local connections from the IPv4 address (127.0.0.1), IPv6 address # (::1) or Unix domain sockets. # # By default protected mode is enabled. You should disable it only if # you are sure you want clients from other hosts to connect to Redis # even if no authentication is configured. protected-mode yes
# 受保护模式是一种安全保护层，旨在避免因 Redis 实例在互联网上开放而被访问和利用。# # 当受保护模式开启且默认用户没有密码时，服务器只接受来自 IPv4 地址（127.0.0.1）、IPv6 地址（::1）或 Unix 域套接字的本地连接。# # 默认情况下，受保护模式已启用。只有在确定希望来自其他主机的客户端连接到 Redis 时才应禁用它，即使没有配置身份验证。protected-mode yes

# Redis uses default hardened security configuration directives to reduce the # attack surface on innocent users. Therefore, several sensitive configuration # directives are immutable, and some potentially-dangerous commands are blocked. # # Configuration directives that control files that Redis writes to (e.g., 'dir' # and 'dbfilename') and that aren't usually modified during runtime # are protected by making them immutable. # # Commands that can increase the attack surface of Redis and that aren't usually # called by users are blocked by default. # # These can be exposed to either all connections or just local ones by setting # each of the configs listed below to either of these values: # # no - Block for any connection (remain immutable) # yes - Allow for any connection (no protection) # local - Allow only for local connections. Ones originating from the # IPv4 address (127.0.0.1), IPv6 address (::1) or Unix domain sockets. # # enable-protected-configs no # enable-debug-command no # enable-module-command no
# Redis 使用默认的加固安全配置指令来减少对无辜用户的攻击面。因此，一些敏感的配置指令是不可变的，一些潜在危险的命令被阻止。# # 控制 Redis 写入文件的配置指令（例如'dir'和'dbfilename'）通常在运行时不会被修改，因此通过使它们不可变来保护它们。# # 可增加 Redis 攻击面且通常不会被用户调用的命令默认被阻止。# # 可通过将下面列出的每个配置设置为以下任一值来将其暴露给所有连接或仅本地连接：# # no - 阻止任何连接（保持不可变）# yes - 允许任何连接（无保护）# local - 仅允许本地连接。源自 IPv4 地址（127.0.0.1）、IPv6 地址（::1）或 Unix 域套接字的连接。# # enable-protected-configs no # enable-debug-command no # enable-module-command no

# Accept connections on the specified port, default is 6379 (IANA #815344). # If port 0 is specified Redis will not listen on a TCP socket. port 6379
# 在指定端口接受连接，默认为 6379（IANA＃815344）。# 如果指定端口 0，则 Redis 将不会在 TCP 套接字上侦听。端口 6379

# TCP listen() backlog. # # In high requests-per-second environments you need a high backlog in order # to avoid slow clients connection issues. Note that the Linux kernel # will silently truncate it to the value of /proc/sys/net/core/somaxconn so # make sure to raise both the value of somaxconn and tcp_max_syn_backlog # in order to get the desired effect. tcp-backlog 511
# TCP listen()积压。 # # 在每秒高请求环境中，为了避免慢客户端连接问题，您需要高积压。注意，Linux 内核会将其静默截断为/proc/sys/net/core/somaxconn 的值，因此请确保提高 somaxconn 和 tcp_max_syn_backlog 的值，以达到预期的效果。tcp-backlog 511

# Unix socket. # # Specify the path for the Unix socket that will be used to listen for # incoming connections. There is no default, so Redis will not listen # on a unix socket when not specified. # # unixsocket /run/redis.sock # unixsocketperm 700
# Unix 套接字。# #指定用于侦听传入连接的 Unix 套接字的路径。没有默认值，因此未指定时 Redis 不会侦听 Unix 套接字。# # unixsocket /run/redis.sock # unixsocketperm 700

# Close the connection after a client is idle for N seconds (0 to disable) timeout 0
# 在客户端空闲 N 秒后关闭连接（0 为禁用）超时 0

# TCP keepalive. # # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence # of communication. This is useful for two reasons: # # 1) Detect dead peers. # 2) Force network equipment in the middle to consider the connection to be # alive. # # On Linux, the specified value (in seconds) is the period used to send ACKs. # Note that to close the connection the double of the time is needed. # On other kernels the period depends on the kernel configuration. # # A reasonable value for this option is 300 seconds, which is the new # Redis default starting with Redis 3.2.1. tcp-keepalive 300
# TCP keepalive. # # 如果非零，使用 SO_KEEPALIVE 发送 TCP ACKs 到客户端，在缺乏通信时。这对两个原因都很有用：# # 1) 检测死对等体。# 2) 强制中间的网络设备认为连接是# 活着的。# # 在 Linux 上，指定的时间（以秒为单位）用于发送 ACKs 的期间。# 注意，为了关闭连接，需要加倍的时间。# 在其他内核上，周期取决于内核配置。# # 此选项的合理值为 300 秒，这是新的# Redis 默认值，从 Redis 3.2.1 开始。tcp-keepalive 300

# Apply OS-specific mechanism to mark the listening socket with the specified # ID, to support advanced routing and filtering capabilities. # # On Linux, the ID represents a connection mark. # On FreeBSD, the ID represents a socket cookie ID. # On OpenBSD, the ID represents a route table ID. # # The default value is 0, which implies no marking is required. # socket-mark-id 0
# 应用特定于操作系统的机制来标记使用指定 ID 的监听套接字，以支持高级路由和过滤功能。 # # 在 Linux 上，ID 表示连接标记。 # 在 FreeBSD 上，ID 表示套接字 cookie ID。 # 在 OpenBSD 上，ID 表示路由表 ID。 # # 默认值为 0，表示不需要标记。 # 套接字标记 ID 0

################################# TLS/SSL #####################################

# By default, TLS/SSL is disabled. To enable it, the "tls-port" configuration # directive can be used to define TLS-listening ports. To enable TLS on the # default port, use: # # port 0 # tls-port 6379
# 默认情况下，TLS/SSL 已禁用。要启用它，可以使用“tls-port”配置指令来定义 TLS 监听端口。要在默认端口上启用 TLS，请使用：# # port 0 # tls-port 6379

# Configure a X.509 certificate and private key to use for authenticating the # server to connected clients, masters or cluster peers. These files should be # PEM formatted. # # tls-cert-file redis.crt # tls-key-file redis.key # # If the key file is encrypted using a passphrase, it can be included here # as well. # # tls-key-file-pass secret
# 配置用于向连接的客户端、主服务器或集群对等体进行身份验证的 X.509 证书和私钥。这些文件应该是 PEM 格式的。# # tls-cert-file redis.crt # tls-key-file redis.key # # 如果密钥文件使用密码短语加密，也可以在这里包含。# # tls-key-file-pass secret

# Normally Redis uses the same certificate for both server functions (accepting # connections) and client functions (replicating from a master, establishing # cluster bus connections, etc.). # # Sometimes certificates are issued with attributes that designate them as # client-only or server-only certificates. In that case it may be desired to use # different certificates for incoming (server) and outgoing (client) # connections. To do that, use the following directives: # # tls-client-cert-file client.crt # tls-client-key-file client.key # # If the key file is encrypted using a passphrase, it can be included here # as well. # # tls-client-key-file-pass secret
# 通常情况下，Redis 同时用于服务器功能（接受连接）和客户端功能（从主服务器复制、建立集群总线连接等）的相同证书。 # # 有时会发放带有指定为仅客户端或仅服务器的属性的证书。在这种情况下，可能希望为传入（服务器）和传出（客户端）连接使用不同的证书。要实现这一点，请使用以下指令： # # tls-client-cert-file client.crt # tls-client-key-file client.key # # 如果密钥文件使用密码短语加密，也可以在此处包含。 # # tls-client-key-file-pass secret

# Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange, # required by older versions of OpenSSL (<3.0). Newer versions do not require # this configuration and recommend against it. # # tls-dh-params-file redis.dh
#配置 DH 参数文件以启用 Diffie-Hellman(DH)密钥交换，#早期版本的 OpenSSL (<3.0)需要此配置。较新版不需要#此配置，并建议不要使用此配置。# # tls-dh-params-file redis.dh

# Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL # clients and peers. Redis requires an explicit configuration of at least one # of these, and will not implicitly use the system wide configuration. # # tls-ca-cert-file ca.crt # tls-ca-cert-dir /etc/ssl/certs
# 配置 CA 证书包或目录以验证 TLS/SSL 客户端和对等方。Redis 需要至少配置其中一个，不会隐式使用系统范围的配置。# # tls-ca-cert-file ca.crt # tls-ca-cert-dir /etc/ssl/certs

# By default, clients (including replica servers) on a TLS port are required # to authenticate using valid client side certificates. # # If "no" is specified, client certificates are not required and not accepted. # If "optional" is specified, client certificates are accepted and must be # valid if provided, but are not required. # # tls-auth-clients no # tls-auth-clients optional
#默认情况下，TLS 端口上的客户端（包括副本服务器）需要使用有效的客户端证书进行身份验证。# #如果指定“no”，则不需要客户端证书，也不接受。#如果指定“optional”，则接受客户端证书并且必须有效（如果提供），但不是必需的。# # tls-auth-clients no # tls-auth-clients optional

# By default, a Redis replica does not attempt to establish a TLS connection # with its master. # # Use the following directive to enable TLS on replication links. # # tls-replication yes
#默认情况下，Redis 副本不会尝试与其主服务器建立 TLS 连接。# #使用以下指令在复制链接上启用 TLS。# #tls-replication yes

# By default, the Redis Cluster bus uses a plain TCP connection. To enable # TLS for the bus protocol, use the following directive: # # tls-cluster yes
# 默认情况下，Redis Cluster 总线使用普通的 TCP 连接。要为总线协议启用 TLS，请使用以下指令：# # tls-cluster yes

# By default, only TLSv1.2 and TLSv1.3 are enabled and it is highly recommended # that older formally deprecated versions are kept disabled to reduce the attack surface. # You can explicitly specify TLS versions to support. # Allowed values are case insensitive and include "TLSv1", "TLSv1.1", "TLSv1.2", # "TLSv1.3" (OpenSSL >= 1.1.1) or any combination. # To enable only TLSv1.2 and TLSv1.3, use: # # tls-protocols "TLSv1.2 TLSv1.3"
＃默认情况下，仅启用 TLSv1.2 和 TLSv1.3，并强烈建议将旧版已弃用版本保持禁用，以减少攻击面。您可以明确指定要支持的 TLS 版本。允许的值不区分大小写，包括"TLSv1"，"TLSv1.1"，"TLSv1.2"，＃"TLSv1.3"（OpenSSL> = 1.1.1）或任何组合。要仅启用 TLSv1.2 和 TLSv1.3，请使用：＃tls-protocols“TLSv1.2 TLSv1.3”

# Configure allowed ciphers. See the ciphers(1ssl) manpage for more information # about the syntax of this string. # # Note: this configuration applies only to <= TLSv1.2. # # tls-ciphers DEFAULT:!MEDIUM
# 配置允许的密码。有关此字符串语法的更多信息，请参阅 ciphers(1ssl)手册页。# # 注意：此配置仅适用于<= TLSv1.2。# # tls-ciphers DEFAULT:!MEDIUM

# Configure allowed TLSv1.3 ciphersuites. See the ciphers(1ssl) manpage for more # information about the syntax of this string, and specifically for TLSv1.3 # ciphersuites. # # tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256
# 配置允许的 TLSv1.3 密码套件。有关此字符串语法的更多信息，请参阅 ciphers(1ssl)手册页，特别是有关 TLSv1.3 密码套件的信息。# # tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256

# When choosing a cipher, use the server's preference instead of the client # preference. By default, the server follows the client's preference. # # tls-prefer-server-ciphers yes
# 在选择密码时，请使用服务器的偏好而不是客户端的偏好。默认情况下，服务器遵循客户端的偏好。# # tls-prefer-server-ciphers yes

# By default, TLS session caching is enabled to allow faster and less expensive # reconnections by clients that support it. Use the following directive to disable # caching. # # tls-session-caching no
# 默认情况下，启用 TLS 会话缓存，以允许支持它的客户端更快、更便宜地重新连接。使用以下指令禁用缓存。# # tls-session-caching no

# Change the default number of TLS sessions cached. A zero value sets the cache # to unlimited size. The default size is 20480. # # tls-session-cache-size 5000
# 更改默认的 TLS 会话缓存数量。零值将缓存设置为无限大小。默认大小为 20480。# # tls-session-cache-size 5000

# Change the default timeout of cached TLS sessions. The default timeout is 300 # seconds. # # tls-session-cache-timeout 60
# 更改缓存的 TLS 会话的默认超时时间。默认超时时间为 300 秒。# # tls-session-cache-timeout 60

################################# GENERAL #####################################
################################# 一般 #####################################

# By default Redis does not run as a daemon. Use 'yes' if you need it. # Note that Redis will write a pid file in /var/run/redis.pid when daemonized. # When Redis is supervised by upstart or systemd, this parameter has no impact. daemonize no
默认情况下，Redis 不作为守护进程运行。如果需要，请使用“yes”。请注意，当 Redis 被守护时，会在 /var/run/redis.pid 写入一个 pid 文件。当 Redis 被 upstart 或 systemd 监控时，此参数不会产生影响。daemonize no

# If you run Redis from upstart or systemd, Redis can interact with your # supervision tree. Options: # supervised no - no supervision interaction # supervised upstart - signal upstart by putting Redis into SIGSTOP mode # requires "expect stop" in your upstart job config # supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET # on startup, and updating Redis status on a regular # basis. # supervised auto - detect upstart or systemd method based on # UPSTART_JOB or NOTIFY_SOCKET environment variables # Note: these supervision methods only signal "process is ready." # They do not enable continuous pings back to your supervisor. # # The default is "no". To run under upstart/systemd, you can simply uncomment # the line below: # # supervised auto
＃如果您从 upstart 或 systemd 运行 Redis，则 Redis 可以与您的监督树交互。 选项：#监督无-无监督交互#监督 upstart-通过将 Redis 置于 SIGSTOP 模式来向 upstart 发送信号#在您的 upstart 作业配置中需要“expect stop”#监督 systemd-通过向$NOTIFY_SOCKET 写入 READY=1 来向 systemd 发送信号#在启动时，并定期更新 Redis 状态#监督自动-根据 UPSTART_JOB 或 NOTIFY_SOCKET 环境变量检测 upstart 或 systemd 方法#注意：这些监督方法仅信号“进程已准备就绪”。#它们不会启用连续的 ping 返回到您的监督员。#默认值为“否”。要在 upstart/systemd 下运行，您只需取消注释下面的行：#监督自动

# If a pid file is specified, Redis writes it where specified at startup # and removes it at exit. # # When the server runs non daemonized, no pid file is created if none is # specified in the configuration. When the server is daemonized, the pid file # is used even if not specified, defaulting to "/var/run/redis.pid". # # Creating a pid file is best effort: if Redis is not able to create it # nothing bad happens, the server will start and run normally. # # Note that on modern Linux systems "/run/redis.pid" is more conforming # and should be used instead. pidfile /var/run/redis_6379.pid
# 如果指定了 pid 文件，则 Redis 会在启动时将其写入指定的位置，并在退出时将其删除。# # 当服务器以非守护进程运行时，如果在配置中未指定 pid 文件，则不会创建 pid 文件。当服务器以守护进程运行时，即使未指定，也会使用 pid 文件，默认为“/var/run/redis.pid”。# # 创建 pid 文件是最佳努力：如果 Redis 无法创建它，不会发生任何不良情况，服务器将正常启动和运行。# # 请注意，在现代 Linux 系统上，“/run/redis.pid”更符合规范，应该使用它。pidfile /var/run/redis_6379.pid

# Specify the server verbosity level. # This can be one of: # debug (a lot of information, useful for development/testing) # verbose (many rarely useful info, but not a mess like the debug level) # notice (moderately verbose, what you want in production probably) # warning (only very important / critical messages are logged) # nothing (nothing is logged) loglevel notice
# 指定服务器的详细程度。# 这可以是以下之一：# 调试（大量信息，对开发/测试很有用）# 冗长（许多很少有用的信息，但不像调试级别那样混乱）# 注意（适度详细，可能是生产中需要的）# 警告（只记录非常重要/关键的消息）# 无（不记录任何内容）日志级别注意

# Specify the log file name. Also the empty string can be used to force # Redis to log on the standard output. Note that if you use standard # output for logging but daemonize, logs will be sent to /dev/null logfile ""
# 指定日志文件名。也可以使用空字符串来强制 Redis 记录在标准输出上。请注意，如果您将标准输出用于日志记录但进行守护进程化，日志将被发送到/dev/null 日志文件""

# To enable logging to the system logger, just set 'syslog-enabled' to yes, # and optionally update the other syslog parameters to suit your needs. # syslog-enabled no
＃要启用记录到系统日志记录器，只需将'syslog-enabled'设置为是，＃并可选择更新其他 syslog 参数以满足您的需求。＃syslog-enabled 否

# Specify the syslog identity. # syslog-ident redis
# 指定 syslog 标识。# syslog-ident redis

# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7. # syslog-facility local0
# 指定 syslog 设施。必须是 USER 或在 LOCAL0-LOCAL7 之间。# syslog-facility local0

# To disable the built in crash log, which will possibly produce cleaner core # dumps when they are needed, uncomment the following: # # crash-log-enabled no
# 要禁用内置的崩溃日志，可能会在需要时生成更干净的核心转储，请取消以下注释：# # crash-log-enabled no

# To disable the fast memory check that's run as part of the crash log, which # will possibly let redis terminate sooner, uncomment the following: # # crash-memcheck-enabled no
要禁用作为崩溃日志的一部分运行的快速内存检查，这可能会让 Redis 更早终止，请取消以下注释：# crash-memcheck-enabled no

# Set the number of databases. The default database is DB 0, you can select # a different one on a per-connection basis using SELECT <dbid> where # dbid is a number between 0 and 'databases'-1 databases 16
#设置数据库数量。默认数据库是 DB 0，你可以选择一个不同的数据库，使用 SELECT <dbid>，其中# dbid 是 0 到“databases”-1 之间的数字。数据库 16

# By default Redis shows an ASCII art logo only when started to log to the # standard output and if the standard output is a TTY and syslog logging is # disabled. Basically this means that normally a logo is displayed only in # interactive sessions. # # However it is possible to force the pre-4.0 behavior and always show a # ASCII art logo in startup logs by setting the following option to yes. always-show-logo no
# 默认情况下，Redis 仅在启动记录到标准输出时显示 ASCII 艺术标志，如果标准输出是 TTY 并且 syslog 日志记录已禁用。基本上，这意味着通常仅在交互会话中显示标志。# # 但是，可以通过将以下选项设置为是来强制执行先前的 4.0 行为，并始终在启动日志中显示 ASCII 艺术标志。始终显示标志 否

# To avoid logging personal identifiable information (PII) into server log file, # uncomment the following: # # hide-user-data-from-log yes
为避免将个人可识别信息（PII）记录到服务器日志文件中，取消以下注释：#从日志中隐藏用户数据 yes

# By default, Redis modifies the process title (as seen in 'top' and 'ps') to # provide some runtime information. It is possible to disable this and leave # the process name as executed by setting the following to no. set-proc-title yes
# Redis 默认会修改进程标题（在“top”和“ps”中可以看到）以提供一些运行时信息。可以通过将以下设置为 no 来禁用此功能并保留作为执行的进程名称。set-proc-title yes

# When changing the process title, Redis uses the following template to construct # the modified title. # # Template variables are specified in curly brackets. The following variables are # supported: # # {title} Name of process as executed if parent, or type of child process. # {listen-addr} Bind address or '*' followed by TCP or TLS port listening on, or # Unix socket if only that's available. # {server-mode} Special mode, i.e. "[sentinel]" or "[cluster]". # {port} TCP port listening on, or 0. # {tls-port} TLS port listening on, or 0. # {unixsocket} Unix domain socket listening on, or "". # {config-file} Name of configuration file used. # proc-title-template "{title} {listen-addr} {server-mode}"
# 当更改进程标题时，Redis 使用以下模板来构建修改后的标题。# # 模板变量在花括号中指定。支持以下变量：# # {title} 父进程执行时的进程名称，或子进程的类型。# {listen-addr} 绑定地址或'*'后跟 TCP 或 TLS 端口监听，或# 仅可用的 Unix 套接字。# {server-mode} 特殊模式，即"[sentinel]"或"[cluster]"。# {port} TCP 端口监听，或 0。# {tls-port} TLS 端口监听，或 0。# {unixsocket} Unix 域套接字监听，或""。# {config-file} 使用的配置文件名称。# proc-title-template "{title} {listen-addr} {server-mode}"

# Set the local environment which is used for string comparison operations, and # also affect the performance of Lua scripts. Empty String indicates the locale # is derived from the environment variables. locale-collate ""
# 设置本地环境，用于字符串比较操作，并影响 Lua 脚本的性能。空字符串表示本地环境派生自环境变量。locale-collate ""

################################ SNAPSHOTTING ################################
################################ 快照 ################################

# Save the DB to disk. # # save <seconds> <changes> [<seconds> <changes> ...] # # Redis will save the DB if the given number of seconds elapsed and it # surpassed the given number of write operations against the DB. # # Snapshotting can be completely disabled with a single empty string argument # as in following example: # # save "" # # Unless specified otherwise, by default Redis will save the DB: # * After 3600 seconds (an hour) if at least 1 change was performed # * After 300 seconds (5 minutes) if at least 100 changes were performed # * After 60 seconds if at least 10000 changes were performed # # You can set these explicitly by uncommenting the following line. # # save 3600 1 300 100 60 10000
＃将 DB 保存到磁盘。＃＃保存<秒> <更改> [<秒> <更改> ...]＃＃如果经过给定的秒数并且超过了对 DB 的写操作的给定次数，则 Redis 将保存 DB。＃＃快照可以通过单个空字符串参数完全禁用，如以下示例中所示：＃＃保存""＃＃除非另有说明，否则默认情况下 Redis 将保存 DB：＃*在至少执行 1 次更改后的 3600 秒（1 小时）＃*在至少执行 100 次更改后的 300 秒（5 分钟）＃*在至少执行 10000 次更改后的 60 秒＃＃您可以通过取消注释以下行来明确设置这些值。＃＃保存 3600 1 300 100 60 10000

# By default Redis will stop accepting writes if RDB snapshots are enabled # (at least one save point) and the latest background save failed. # This will make the user aware (in a hard way) that data is not persisting # on disk properly, otherwise chances are that no one will notice and some # disaster will happen. # # If the background saving process will start working again Redis will # automatically allow writes again. # # However if you have setup your proper monitoring of the Redis server # and persistence, you may want to disable this feature so that Redis will # continue to work as usual even if there are problems with disk, # permissions, and so forth. stop-writes-on-bgsave-error yes
# 默认情况下，如果启用了 RDB 快照（至少一个保存点）并且最新的后台保存失败，Redis 将停止接受写入。这将使用户意识到数据未正确持久化在磁盘上，否则可能没有人注意到并且可能会发生一些灾难。如果后台保存过程重新开始工作，Redis 将自动再次允许写入。但是，如果您已经设置了 Redis 服务器和持久性的适当监控，您可能希望禁用此功能，以便 Redis 将继续像往常一样工作，即使磁盘、权限等出现问题。stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases? # By default compression is enabled as it's almost always a win. # If you want to save some CPU in the saving child set it to 'no' but # the dataset will likely be bigger if you have compressible values or keys. rdbcompression yes
# 在转储 rdb 数据库时使用 LZF 压缩字符串对象？ # 默认情况下，启用压缩通常是一个胜利。 # 如果您想节省一些 CPU，请将其设置为“否”，但是 # 如果您具有可压缩的值或键，则数据集可能会更大。 rdbcompression 是的

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file. # This makes the format more resistant to corruption but there is a performance # hit to pay (around 10%) when saving and loading RDB files, so you can disable it # for maximum performances. # # RDB files created with checksum disabled have a checksum of zero that will # tell the loading code to skip the check. rdbchecksum yes
# 从 RDB 的第 5 个版本开始，在文件末尾放置了一个 CRC64 校验和。# 这使得格式更加抗损坏，但在保存和加载 RDB 文件时会有性能损失（大约 10%），因此您可以禁用它以获得最佳性能。# # 禁用校验和创建的 RDB 文件具有零校验和，这将告诉加载代码跳过检查。rdbchecksum yes

# Enables or disables full sanitization checks for ziplist and listpack etc when # loading an RDB or RESTORE payload. This reduces the chances of a assertion or # crash later on while processing commands. # Options: # no - Never perform full sanitization # yes - Always perform full sanitization # clients - Perform full sanitization only for user connections. # Excludes: RDB files, RESTORE commands received from the master # connection, and client connections which have the # skip-sanitize-payload ACL flag. # The default should be 'clients' but since it currently affects cluster # resharding via MIGRATE, it is temporarily set to 'no' by default. # # sanitize-dump-payload no
# 在加载 RDB 或 RESTORE 负载时，启用或禁用对 ziplist 和 listpack 等的完全消毒检查。这样可以减少在处理命令时后续发生断言或崩溃的机会。# 选项：# no - 从不执行完全消毒# yes - 总是执行完全消毒# clients - 仅为用户连接执行完全消毒。# 排除：RDB 文件、从主连接接收的 RESTORE 命令、以及具有 skip-sanitize-payload ACL 标志的客户端连接。# 默认应为“clients”，但由于当前通过 MIGRATE 影响集群重新分片，因此默认临时设置为“no”。# # sanitize-dump-payload no

# The filename where to dump the DB dbfilename dump.rdb
＃要转储 DB 的文件名 dbfilename dump.rdb

# Remove RDB files used by replication in instances without persistence # enabled. By default this option is disabled, however there are environments # where for regulations or other security concerns, RDB files persisted on # disk by masters in order to feed replicas, or stored on disk by replicas # in order to load them for the initial synchronization, should be deleted # ASAP. Note that this option ONLY WORKS in instances that have both AOF # and RDB persistence disabled, otherwise is completely ignored. # # An alternative (and sometimes better) way to obtain the same effect is # to use diskless replication on both master and replicas instances. However # in the case of replicas, diskless is not always an option. rdb-del-sync-files no
＃删除未启用持久性的实例中复制使用的 RDB 文件。 默认情况下，此选项已禁用，但在某些环境中，为了遵守法规或其他安全问题，主服务器在磁盘上持久化 RDB 文件以供副本使用，或者副本在磁盘上存储 RDB 文件以用于初始同步，应尽快删除。 请注意，此选项仅在同时禁用 AOF 和 RDB 持久性的实例中有效，否则将完全被忽略。＃＃获得相同效果的另一种（有时更好的）方法是在主服务器和副本实例上使用无磁盘复制。 但是在副本的情况下，无磁盘并不总是一个选择。 rdb-del-sync-files no

# The working directory. # # The DB will be written inside this directory, with the filename specified # above using the 'dbfilename' configuration directive. # # The Append Only File will also be created inside this directory. # # Note that you must specify a directory here, not a file name. dir ./
＃工作目录。＃＃DB 将写入此目录中，文件名使用“dbfilename”配置指令指定。＃＃追加文件也将在此目录中创建。＃＃请注意，您必须在此处指定一个目录，而不是一个文件名。dir ./

################################# REPLICATION #################################
################################# 复制 #################################

# Master-Replica replication. Use replicaof to make a Redis instance a copy of # another Redis server. A few things to understand ASAP about Redis replication. # # +------------------+ +---------------+ # | Master | ---> | Replica | # | (receive writes) | | (exact copy) | # +------------------+ +---------------+ # # 1) Redis replication is asynchronous, but you can configure a master to # stop accepting writes if it appears to be not connected with at least # a given number of replicas. # 2) Redis replicas are able to perform a partial resynchronization with the # master if the replication link is lost for a relatively small amount of # time. You may want to configure the replication backlog size (see the next # sections of this file) with a sensible value depending on your needs. # 3) Replication is automatic and does not need user intervention. After a # network partition replicas automatically try to reconnect to masters # and resynchronize with them. # # replicaof <masterip> <masterport>
# 主-副本复制。使用 replicaof 将 Redis 实例复制为另一个 Redis 服务器的副本。关于 Redis 复制，有几件事情需要尽快了解。 # # +------------------+ +---------------+ # | 主服务器 | ---> | 副本服务器 | # | (接收写入) | | (精确复制) | # +------------------+ +---------------+ # # 1) Redis 复制是异步的，但您可以配置主服务器，如果它似乎未连接至少给定数量的副本，则停止接受写入。 # 2) Redis 副本能够在复制链接丢失一段相对较短的时间后，与主服务器执行部分重新同步。根据您的需求，您可能希望配置复制后备大小（请参阅本文件的后续部分）为一个合理的值。 # 3) 复制是自动的，不需要用户干预。在网络分区后，副本会自动尝试重新连接到主服务器并与其重新同步。 # # replicaof <主服务器 IP> <主服务器端口>

# If the master is password protected (using the "requirepass" configuration # directive below) it is possible to tell the replica to authenticate before # starting the replication synchronization process, otherwise the master will # refuse the replica request. # # masterauth <master-password> # # However this is not enough if you are using Redis ACLs (for Redis version # 6 or greater), and the default user is not capable of running the PSYNC # command and/or other commands needed for replication. In this case it's # better to configure a special user to use with replication, and specify the # masteruser configuration as such: # # masteruser <username> # # When masteruser is specified, the replica will authenticate against its # master using the new AUTH form: AUTH <username> <password>.
＃如果主服务器受密码保护（使用下面的“requirepass”配置指令），则可以告诉副本在开始复制同步过程之前进行身份验证，否则主服务器将拒绝副本请求。＃＃masterauth <master-password>＃＃但是，如果您正在使用 Redis ACL（适用于 Redis 版本 6 或更高版本），并且默认用户无法运行 PSYNC 命令和/或其他复制所需的命令，则这还不够。在这种情况下，最好配置一个专用用户用于复制，并将 masteruser 配置指定为：＃＃masteruser <username>＃＃指定 masteruser 后，副本将使用新的 AUTH 形式对其主服务器进行身份验证：AUTH <username> <password>。

# When a replica loses its connection with the master, or when the replication # is still in progress, the replica can act in two different ways: # # 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will # still reply to client requests, possibly with out of date data, or the # data set may just be empty if this is the first synchronization. # # 2) If replica-serve-stale-data is set to 'no' the replica will reply with error # "MASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'" # to all data access commands, excluding commands such as: # INFO, REPLICAOF, AUTH, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE, # UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, # HOST and LATENCY. # replica-serve-stale-data yes
# 当副本与主服务器失去连接或复制仍在进行时，副本可以以两种不同的方式进行操作： # # 1) 如果 replica-serve-stale-data 设置为 'yes'（默认值），副本仍将回复客户端请求，可能会使用过时的数据，或者如果这是第一次同步，则数据集可能为空。 # # 2) 如果 replica-serve-stale-data 设置为 'no'，副本将对所有数据访问命令回复错误“MASTERDOWN 主服务器连接已断开，且 replica-serve-stale-data 设置为 'no'”，但不包括以下命令： # INFO、REPLICAOF、AUTH、SHUTDOWN、REPLCONF、ROLE、CONFIG、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE、PUNSUBSCRIBE、PUBLISH、PUBSUB、COMMAND、POST、HOST 和 LATENCY。 # replica-serve-stale-data yes

# You can configure a replica instance to accept writes or not. Writing against # a replica instance may be useful to store some ephemeral data (because data # written on a replica will be easily deleted after resync with the master) but # may also cause problems if clients are writing to it because of a # misconfiguration. # # Since Redis 2.6 by default replicas are read-only. # # Note: read only replicas are not designed to be exposed to untrusted clients # on the internet. It's just a protection layer against misuse of the instance. # Still a read only replica exports by default all the administrative commands # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve # security of read only replicas using 'rename-command' to shadow all the # administrative / dangerous commands. replica-read-only yes
# 您可以配置副本实例是否接受写入。针对副本实例的写入可能对存储一些临时数据有用（因为在与主服务器重新同步后，副本上写入的数据将很容易被删除），但如果客户端正在向其写入，可能也会引起问题，因为可能存在配置错误。# # 自 Redis 2.6 起，默认情况下副本是只读的。# # 注意：只读副本不适用于暴露给互联网上的不受信任的客户端。这只是对实例被误用的一种保护层。只读副本默认情况下仍会导出所有管理命令，如 CONFIG、DEBUG 等。在一定程度上，您可以使用 'rename-command' 来阴影所有管理/危险命令，以提高只读副本的安全性。 replica-read-only yes

# Replication SYNC strategy: disk or socket. # # New replicas and reconnecting replicas that are not able to continue the # replication process just receiving differences, need to do what is called a # "full synchronization". An RDB file is transmitted from the master to the # replicas. # # The transmission can happen in two different ways: # # 1) Disk-backed: The Redis master creates a new process that writes the RDB # file on disk. Later the file is transferred by the parent # process to the replicas incrementally. # 2) Diskless: The Redis master creates a new process that directly writes the # RDB file to replica sockets, without touching the disk at all. # # With disk-backed replication, while the RDB file is generated, more replicas # can be queued and served with the RDB file as soon as the current child # producing the RDB file finishes its work. With diskless replication instead # once the transfer starts, new replicas arriving will be queued and a new # transfer will start when the current one terminates. # # When diskless replication is used, the master waits a configurable amount of # time (in seconds) before starting the transfer in the hope that multiple # replicas will arrive and the transfer can be parallelized. # # With slow disks and fast (large bandwidth) networks, diskless replication # works better. repl-diskless-sync yes
# 复制 SYNC 策略：磁盘或套接字。 # # 需要执行全同步的新副本和重新连接的副本，不能继续 # 复制流程只收到差异，所谓“全同步”。一个 RDB 文件从主节点传输到 # 副本。 # # 传输可以采用两种不同的方式： # # 1）磁盘备份：Redis 主节点创建一个新进程，写入 RDB # 文件存储在磁盘上。稍后父进程将文件增量传输到副本。 # 2）无磁盘：Redis 主节点创建一个新进程，直接写入 # RDB 文件到副本套接字，不触及磁盘。 # # 使用磁盘备份复制，当生成 RDB 文件时，更多副本 # 可以排队并使用 RDB 文件，一旦生成 RDB 文件的当前子节点完成其工作。 使用无磁盘复制，一旦传输开始，到达的新副本将排队 # 当当前传输终止时，将启动新的传输。 当使用无盘复制时，主节点在开始传输之前会等待可配置的时间（以秒为单位），希望多个副本到达，可以并行传输。当磁盘速度较慢，网络带宽较快时，无盘复制效果更好。repl-diskless-sync 是的

# When diskless replication is enabled, it is possible to configure the delay # the server waits in order to spawn the child that transfers the RDB via socket # to the replicas. # # This is important since once the transfer starts, it is not possible to serve # new replicas arriving, that will be queued for the next RDB transfer, so the # server waits a delay in order to let more replicas arrive. # # The delay is specified in seconds, and by default is 5 seconds. To disable # it entirely just set it to 0 seconds and the transfer will start ASAP. repl-diskless-sync-delay 5
当启用无盘复制时，可以配置服务器等待生成传输 RDB 到副本的孩子的延迟时间。这是很重要的，因为一旦传输开始，就无法为新到达的副本提供服务，它们将被排队等待下一个 RDB 传输，因此服务器等待延迟以让更多的副本到达。延迟时间以秒为单位指定，默认情况下为 5 秒。要完全禁用它，只需将其设置为 0 秒，传输将立即开始。 repl-diskless-sync-delay 5

# When diskless replication is enabled with a delay, it is possible to let # the replication start before the maximum delay is reached if the maximum # number of replicas expected have connected. Default of 0 means that the # maximum is not defined and Redis will wait the full delay. repl-diskless-sync-max-replicas 0
# 当启用延迟的无盘复制时，如果预期的最大副本数量已连接，则可以在达到最大延迟之前启动复制。默认值为 0 表示最大值未定义，Redis 将等待完整的延迟。 repl-diskless-sync-max-replicas 0

# ----------------------------------------------------------------------------- # WARNING: Since in this setup the replica does not immediately store an RDB on # disk, it may cause data loss during failovers. RDB diskless load + Redis # modules not handling I/O reads may cause Redis to abort in case of I/O errors # during the initial synchronization stage with the master. # ----------------------------------------------------------------------------- # # Replica can load the RDB it reads from the replication link directly from the # socket, or store the RDB to a file and read that file after it was completely # received from the master. # # In many cases the disk is slower than the network, and storing and loading # the RDB file may increase replication time (and even increase the master's # Copy on Write memory and replica buffers). # However, when parsing the RDB file directly from the socket, in order to avoid # data loss it's only safe to flush the current dataset when the new dataset is # fully loaded in memory, resulting in higher memory usage. # For this reason we have the following options: # # "disabled" - Don't use diskless load (store the rdb file to the disk first) # "swapdb" - Keep current db contents in RAM while parsing the data directly # from the socket. Replicas in this mode can keep serving current # dataset while replication is in progress, except for cases where # they can't recognize master as having a data set from same # replication history. # Note that this requires sufficient memory, if you don't have it, # you risk an OOM kill. # "on-empty-db" - Use diskless load only when current dataset is empty. This is # safer and avoid having old and new dataset loaded side by side # during replication. repl-diskless-load disabled
# ----------------------------------------------------------------------------- # 警告：由于在这种设置中，副本不会立即将 RDB 存储到磁盘上，因此在故障转移期间可能会导致数据丢失。RDB 无磁盘加载+Redis #模块不能处理 I/O 读取时，在与主服务器进行初始同步阶段期间，可能会导致 Redis 中止。 # ----------------------------------------------------------------------------- # # 副本可以直接从复制链接中读取的 RDB 进行加载或将 RDB 存储到文件并在完全从主服务器接收后读取该文件。 # # 在许多情况下，磁盘比网络慢，并存储和加载#RDB 文件可能会增加复制时间（甚至增加主副本在写内存和复制缓冲区上的负担）。 #但是，在直接从套接字解析 RDB 文件时，为了避免数据丢失，只有在新数据集完全加载到内存中时才安全地刷新当前数据集，从而导致更高的内存使用率。 为此，我们有以下选项：# # "disabled" - 不使用无盘加载（首先将 rdb 文件存储到磁盘）# "swapdb" - 在直接解析数据时将当前数据库内容保留在 RAM 中# 来自套接字。在此模式下，副本可以在复制进行中继续提供当前# 数据集，除非# 他们无法识别主服务器是否具有相同的数据集# 复制历史。# 请注意，这需要足够的内存，如果您没有，# 您会面临 OOM 杀。# "on-empty-db" - 仅在当前数据集为空时才使用无盘加载。这是# 更安全的，避免在复制过程中同时加载旧数据集和新数据集。禁用 repl-diskless-load

# Master send PINGs to its replicas in a predefined interval. It's possible to # change this interval with the repl_ping_replica_period option. The default # value is 10 seconds. # # repl-ping-replica-period 10
# 主节点以预定义的间隔向其副本发送 PING。可以使用 repl_ping_replica_period 选项更改此间隔。默认值为 10 秒。# # repl-ping-replica-period 10

# The following option sets the replication timeout for: # # 1) Bulk transfer I/O during SYNC, from the point of view of replica. # 2) Master timeout from the point of view of replicas (data, pings). # 3) Replica timeout from the point of view of masters (REPLCONF ACK pings). # # It is important to make sure that this value is greater than the value # specified for repl-ping-replica-period otherwise a timeout will be detected # every time there is low traffic between the master and the replica. The default # value is 60 seconds. # # repl-timeout 60
# 以下选项设置了复制超时时间：# # 1）在 SYNC 期间进行批量传输 I/O，从副本的角度来看。# 2）从副本的角度来看的主超时（数据，ping）。# 3）从主服务器的角度来看的副本超时（REPLCONF ACK ping）。# # 重要的是确保此值大于 repl-ping-replica-period 指定的值，否则每当主服务器和副本之间的流量较低时都会检测到超时。默认值为 60 秒。# # repl-timeout 60

# Disable TCP_NODELAY on the replica socket after SYNC? # # If you select "yes" Redis will use a smaller number of TCP packets and # less bandwidth to send data to replicas. But this can add a delay for # the data to appear on the replica side, up to 40 milliseconds with # Linux kernels using a default configuration. # # If you select "no" the delay for data to appear on the replica side will # be reduced but more bandwidth will be used for replication. # # By default we optimize for low latency, but in very high traffic conditions # or when the master and replicas are many hops away, turning this to "yes" may # be a good idea. repl-disable-tcp-nodelay no
# 在 SYNC 后禁用副本套接字上的 TCP_NODELAY？# # 如果选择“是”，Redis 将使用更少的 TCP 数据包和#较少的带宽向副本发送数据。 但这可能会添加延迟#数据在副本侧出现，直到有#使用默认配置的 Linux 内核的 40 毫秒。# #如果选择“否”，则数据出现在复制品侧的延迟将#减少，但会使用更多的复制带宽。# #默认情况下，我们优化低延迟，但在极高的交通条件下#或当主服务器和复制品距离很远时，将其设置为“是”可能#是一个好主意。 repl-disable-tcp-nodelay no

# Set the replication backlog size. The backlog is a buffer that accumulates # replica data when replicas are disconnected for some time, so that when a # replica wants to reconnect again, often a full resync is not needed, but a # partial resync is enough, just passing the portion of data the replica # missed while disconnected. # # The bigger the replication backlog, the longer the replica can endure the # disconnect and later be able to perform a partial resynchronization. # # The backlog is only allocated if there is at least one replica connected. # # repl-backlog-size 1mb
#设置复制后备日志大小。后备日志是一个缓冲区，在复制品断开连接一段时间后积累副本数据，以便当一个副本想要重新连接时，通常不需要完整的重新同步，而只需要部分重新同步，只通过副本在断开连接时错过的数据部分即可。# # 复制后备越大，副本就能够经受更长时间的断开连接，并且能够执行部分重新同步。# # 只有至少有一个副本连接时，才会分配后备日志。# # repl-backlog-size 1mb

# After a master has no connected replicas for some time, the backlog will be # freed. The following option configures the amount of seconds that need to # elapse, starting from the time the last replica disconnected, for the backlog # buffer to be freed. # # Note that replicas never free the backlog for timeout, since they may be # promoted to masters later, and should be able to correctly "partially # resynchronize" with other replicas: hence they should always accumulate backlog. # # A value of 0 means to never release the backlog. # # repl-backlog-ttl 3600
# 主节点在一段时间内没有连接的副本后，积压将被释放。以下选项配置需要经过多少秒，从最后一个副本断开连接的时间开始计算，积压缓冲区将被释放。# # 请注意，副本永远不会因为超时而释放积压，因为它们可能稍后被提升为主节点，并且应该能够正确地与其他副本“部分重新同步”：因此它们应该始终累积积压。# # 值为 0 表示永不释放积压。# # repl-backlog-ttl 3600

# The replica priority is an integer number published by Redis in the INFO # output. It is used by Redis Sentinel in order to select a replica to promote # into a master if the master is no longer working correctly. # # A replica with a low priority number is considered better for promotion, so # for instance if there are three replicas with priority 10, 100, 25 Sentinel # will pick the one with priority 10, that is the lowest. # # However a special priority of 0 marks the replica as not able to perform the # role of master, so a replica with priority of 0 will never be selected by # Redis Sentinel for promotion. # # By default the priority is 100. replica-priority 100
# 复制品优先级是 Redis 在 INFO 输出中发布的整数，由 Redis Sentinel 用于选择要提升为主服务器的复制品，如果主服务器不再正常工作。# # 优先级数字较低的复制品被认为更适合提升，因此例如，如果有三个优先级为 10、100、25 的复制品，Sentinel 将选择优先级为 10 的那个，即最低的那个。# # 但是，特殊优先级为 0 表示复制品无法执行主服务器的角色，因此优先级为 0 的复制品永远不会被 Redis Sentinel 选择为提升对象。# # 默认情况下，优先级为 100。 replica-priority 100

# The propagation error behavior controls how Redis will behave when it is # unable to handle a command being processed in the replication stream from a master # or processed while reading from an AOF file. Errors that occur during propagation # are unexpected, and can cause data inconsistency. However, there are edge cases # in earlier versions of Redis where it was possible for the server to replicate or persist # commands that would fail on future versions. For this reason the default behavior # is to ignore such errors and continue processing commands. # # If an application wants to ensure there is no data divergence, this configuration # should be set to 'panic' instead. The value can also be set to 'panic-on-replicas' # to only panic when a replica encounters an error on the replication stream. One of # these two panic values will become the default value in the future once there are # sufficient safety mechanisms in place to prevent false positive crashes. # # propagation-error-behavior ignore
# 传播错误行为控制 Redis 在无法处理正在处理的命令时的行为 # 从主复制流中或在从 AOF 文件中读取时处理。传播期间发生的错误 # 是意外的，可能导致数据不一致。但是，存在边缘情况 # 在早期版本的 Redis 中，服务器可以复制或持久化 # 未来版本中将失败的命令。因此，默认行为 # 是忽略此类错误并继续处理命令。 # # 如果应用程序希望确保没有数据分歧，此配置 # 应设置为“panic”。该值也可以设置为“panic-on-replicas” # 仅在副本在复制流上遇到错误时才会发生紧急情况。其中之一 # 这两个紧急值将在未来成为默认值 # 一旦有足够的安全机制防止误报崩溃。 # # 传播错误行为 忽略

# Replica ignore disk write errors controls the behavior of a replica when it is # unable to persist a write command received from its master to disk. By default, # this configuration is set to 'no' and will crash the replica in this condition. # It is not recommended to change this default, however in order to be compatible # with older versions of Redis this config can be toggled to 'yes' which will just # log a warning and execute the write command it got from the master. # # replica-ignore-disk-write-errors no
# 复制品忽略磁盘写入错误控制副本的行为当它无法将来自主服务器的写入命令持久保存到磁盘。默认情况下，此配置设置为“否”，并在此情况下使副本崩溃。不建议更改此默认设置，但是为了与旧版本的 Redis 兼容，可以切换此配置为“是”，这只会记录警告并执行其从主服务器收到的写入命令。# replica-ignore-disk-write-errors no

# ----------------------------------------------------------------------------- # By default, Redis Sentinel includes all replicas in its reports. A replica # can be excluded from Redis Sentinel's announcements. An unannounced replica # will be ignored by the 'sentinel replicas <master>' command and won't be # exposed to Redis Sentinel's clients. # # This option does not change the behavior of replica-priority. Even with # replica-announced set to 'no', the replica can be promoted to master. To # prevent this behavior, set replica-priority to 0. # # replica-announced yes
# ----------------------------------------------------------------------------- # 默认情况下，Redis Sentinel 包括其报告中的所有副本。可以将副本从 Redis Sentinel 的公告中排除。未公布的副本将被 'sentinel replicas <master>' 命令忽略，并且不会暴露给 Redis Sentinel 的客户端。 # # 此选项不会更改副本优先级的行为。即使将 replica-announced 设置为 'no'，副本仍然可以晋升为主服务器。要防止这种行为，请将 replica-priority 设置为 0。 # # replica-announced yes

# It is possible for a master to stop accepting writes if there are less than # N replicas connected, having a lag less or equal than M seconds. # # The N replicas need to be in "online" state. # # The lag in seconds, that must be <= the specified value, is calculated from # the last ping received from the replica, that is usually sent every second. # # This option does not GUARANTEE that N replicas will accept the write, but # will limit the window of exposure for lost writes in case not enough replicas # are available, to the specified number of seconds. # # For example to require at least 3 replicas with a lag <= 10 seconds use: # # min-replicas-to-write 3 # min-replicas-max-lag 10 # # Setting one or the other to 0 disables the feature. # # By default min-replicas-to-write is set to 0 (feature disabled) and # min-replicas-max-lag is set to 10.
如果少于 N 个副本连接，且滞后时间小于等于 M 秒，则主服务器有可能停止接受写入。N 个副本必须处于“在线”状态。滞后时间必须小于或等于指定值，以秒为单位，是从上次接收到副本发送的常规 ping 消息计算得出的，通常每秒发送一次。此选项不能保证 N 个副本都会接受写入，但是在可用的副本不足时，将限制暴露给失去写入的窗口到指定秒数。例如，要求至少有 3 个副本滞后时间小于等于 10 秒，请使用以下命令：min-replicas-to-write 3, min-replicas-max-lag 10。将其中一个设置为 0 会禁用该功能。默认情况下，min-replicas-to-write 设置为 0（禁用该功能），min-replicas-max-lag 设置为 10。

# A Redis master is able to list the address and port of the attached # replicas in different ways. For example the "INFO replication" section # offers this information, which is used, among other tools, by # Redis Sentinel in order to discover replica instances. # Another place where this info is available is in the output of the # "ROLE" command of a master. # # The listed IP address and port normally reported by a replica is # obtained in the following way: # # IP: The address is auto detected by checking the peer address # of the socket used by the replica to connect with the master. # # Port: The port is communicated by the replica during the replication # handshake, and is normally the port that the replica is using to # listen for connections. # # However when port forwarding or Network Address Translation (NAT) is # used, the replica may actually be reachable via different IP and port # pairs. The following two options can be used by a replica in order to # report to its master a specific set of IP and port, so that both INFO # and ROLE will report those values. # # There is no need to use both the options if you need to override just # the port or the IP address. # # replica-announce-ip 5.5.5.5 # replica-announce-port 1234
＃Redis 主机能够以不同的方式列出附加的副本的地址和端口。例如，“INFO replication”部分提供了这些信息，Redis Sentinel 等工具使用这些信息来发现副本实例。另一个可以获取此信息的地方是主机的“ROLE”命令的输出。副本通常报告的列出的 IP 地址和端口是通过以下方式获得的：IP：地址是通过检查副本用于与主机连接的套接字的对等地址自动检测的。端口：端口是在复制握手期间由副本通信的，并且通常是副本用于监听连接的端口。但是，当使用端口转发或网络地址转换（NAT）时，副本实际上可能通过不同的 IP 和端口对可访问。副本可以使用以下两个选项之一，向其主机报告特定的 IP 和端口集，以便 INFO 和 ROLE 都报告这些值。如果您只需要覆盖端口或 IP 地址，则无需同时使用这两个选项。 # # replica-announce-ip 5.5.5.5 # 复制-公告-端口 1234

############################### KEYS TRACKING #################################
############################### 钥匙跟踪 #################################

# Redis implements server assisted support for client side caching of values. # This is implemented using an invalidation table that remembers, using # a radix key indexed by key name, what clients have which keys. In turn # this is used in order to send invalidation messages to clients. Please # check this page to understand more about the feature: # # https://redis.io/topics/client-side-caching # # When tracking is enabled for a client, all the read only queries are assumed # to be cached: this will force Redis to store information in the invalidation # table. When keys are modified, such information is flushed away, and # invalidation messages are sent to the clients. However if the workload is # heavily dominated by reads, Redis could use more and more memory in order # to track the keys fetched by many clients. # # For this reason it is possible to configure a maximum fill value for the # invalidation table. By default it is set to 1M of keys, and once this limit # is reached, Redis will start to evict keys in the invalidation table # even if they were not modified, just to reclaim memory: this will in turn # force the clients to invalidate the cached values. Basically the table # maximum size is a trade off between the memory you want to spend server # side to track information about who cached what, and the ability of clients # to retain cached objects in memory. # # If you set the value to 0, it means there are no limits, and Redis will # retain as many keys as needed in the invalidation table. # In the "stats" INFO section, you can find information about the number of # keys in the invalidation table at every given moment. # # Note: when key tracking is used in broadcasting mode, no memory is used # in the server side so this setting is useless. # # tracking-table-max-keys 1000000
# Redis 实现了服务器辅助支持客户端值缓存。# 这是通过使用一个无效化表来实现的，该表通过键名索引的基数键来记住客户端拥有哪些键。反过来，这用于向客户端发送无效化消息。请查看此页面以了解有关该功能的更多信息：# # https://redis.io/topics/client-side-caching # # 当为客户端启用跟踪时，假定所有只读查询都被缓存：这将强制 Redis 将信息存储在无效化表中。当键被修改时，这些信息将被清除，并且无效化消息将被发送给客户端。但是，如果工作负载主要由读取操作占主导地，Redis 可能会使用更多内存来跟踪许多客户端获取的键。# # 出于这个原因，可以为无效化表配置最大填充值。默认情况下，它设置为 1M 个键，一旦达到此限制，Redis 将开始驱逐无效化表中的键，即使它们没有被修改，只是为了回收内存：这将迫使客户端使缓存值无效。 基本上，表格的最大尺寸是在服务器端跟踪缓存信息的内存和客户端保留缓存对象的能力之间的权衡。如果将值设置为 0，则表示没有限制，Redis 将在失效表中保留所需的键。在“stats”信息部分，您可以找到有关失效表中键的数量的信息。注意：当在广播模式下使用键跟踪时，服务器端不使用内存，因此此设置是无用的。# # tracking-table-max-keys 1000000

################################## SECURITY ###################################
################################## 安全 ###################################

# Warning: since Redis is pretty fast, an outside user can try up to # 1 million passwords per second against a modern box. This means that you # should use very strong passwords, otherwise they will be very easy to break. # Note that because the password is really a shared secret between the client # and the server, and should not be memorized by any human, the password # can be easily a long string from /dev/urandom or whatever, so by using a # long and unguessable password no brute force attack will be possible.
# 警告：由于 Redis 非常快，外部用户可以每秒尝试高达 100 万个密码对现代计算机进行攻击。这意味着您应该使用非常强大的密码，否则它们将很容易被破解。请注意，因为密码实际上是客户端和服务器之间的共享秘密，不应该被任何人记住，密码可以很容易地从/dev/urandom 或其他地方生成一个长字符串，因此使用一个长且难以猜测的密码将不可能发生暴力破解攻击。

# Redis ACL users are defined in the following format: # # user <username> ... acl rules ... # # For example: # # user worker +@list +@connection ~jobs:* on >ffa9203c493aa99 # # The special username "default" is used for new connections. If this user # has the "nopass" rule, then new connections will be immediately authenticated # as the "default" user without the need of any password provided via the # AUTH command. Otherwise if the "default" user is not flagged with "nopass" # the connections will start in not authenticated state, and will require # AUTH (or the HELLO command AUTH option) in order to be authenticated and # start to work. # # The ACL rules that describe what a user can do are the following: # # on Enable the user: it is possible to authenticate as this user. # off Disable the user: it's no longer possible to authenticate # with this user, however the already authenticated connections # will still work. # skip-sanitize-payload RESTORE dump-payload sanitization is skipped. # sanitize-payload RESTORE dump-payload is sanitized (default). # +<command> Allow the execution of that command. # May be used with `|` for allowing subcommands (e.g "+config|get") # -<command> Disallow the execution of that command. # May be used with `|` for blocking subcommands (e.g "-config|set") # +@<category> Allow the execution of all the commands in such category # with valid categories are like @admin, @set, @sortedset, ... # and so forth, see the full list in the server.c file where # the Redis command table is described and defined. # The special category @all means all the commands, but currently # present in the server, and that will be loaded in the future # via modules. # +<command>|first-arg Allow a specific first argument of an otherwise # disabled command. It is only supported on commands with # no sub-commands, and is not allowed as negative form # like -SELECT|1, only additive starting with "+". This # feature is deprecated and may be removed in the future. # allcommands Alias for +@all. Note that it implies the ability to execute # all the future commands loaded via the modules system. # nocommands Alias for -@all. # ~<pattern> Add a pattern of keys that can be mentioned as part of # commands. For instance ~* allows all the keys. The pattern # is a glob-style pattern like the one of KEYS. # It is possible to specify multiple patterns. # %R~<pattern> Add key read pattern that specifies which keys can be read # from. # %W~<pattern> Add key write pattern that specifies which keys can be # written to. # allkeys Alias for ~* # resetkeys Flush the list of allowed keys patterns. # &<pattern> Add a glob-style pattern of Pub/Sub channels that can be # accessed by the user. It is possible to specify multiple channel # patterns. # allchannels Alias for &* # resetchannels Flush the list of allowed channel patterns. # ><password> Add this password to the list of valid password for the user. # For example >mypass will add "mypass" to the list. # This directive clears the "nopass" flag (see later). # <<password> Remove this password from the list of valid passwords. # nopass All the set passwords of the user are removed, and the user # is flagged as requiring no password: it means that every # password will work against this user. If this directive is # used for the default user, every new connection will be # immediately authenticated with the default user without # any explicit AUTH command required. Note that the "resetpass" # directive will clear this condition. # resetpass Flush the list of allowed passwords. Moreover removes the # "nopass" status. After "resetpass" the user has no associated # passwords and there is no way to authenticate without adding # some password (or setting it as "nopass" later). # reset Performs the following actions: resetpass, resetkeys, resetchannels, # allchannels (if acl-pubsub-default is set), off, clearselectors, -@all. # The user returns to the same state it has immediately after its creation. # (<options>) Create a new selector with the options specified within the # parentheses and attach it to the user. Each option should be # space separated. The first character must be ( and the last # character must be ). # clearselectors Remove all of the currently attached selectors. # Note this does not change the "root" user permissions, # which are the permissions directly applied onto the # user (outside the parentheses). # # ACL rules can be specified in any order: for instance you can start with # passwords, then flags, or key patterns. However note that the additive # and subtractive rules will CHANGE MEANING depending on the ordering. # For instance see the following example: # # user alice on +@all -DEBUG ~* >somepassword # # This will allow "alice" to use all the commands with the exception of the # DEBUG command, since +@all added all the commands to the set of the commands # alice can use, and later DEBUG was removed. However if we invert the order # of two ACL rules the result will be different: # # user alice on -DEBUG +@all ~* >somepassword # # Now DEBUG was removed when alice had yet no commands in the set of allowed # commands, later all the commands are added, so the user will be able to # execute everything. # # Basically ACL rules are processed left-to-right. # # The following is a list of command categories and their meanings: # * keyspace - Writing or reading from keys, databases, or their metadata # in a type agnostic way. Includes DEL, RESTORE, DUMP, RENAME, EXISTS, DBSIZE, # KEYS, EXPIRE, TTL, FLUSHALL, etc. Commands that may modify the keyspace, # key or metadata will also have `write` category. Commands that only read # the keyspace, key or metadata will have the `read` category. # * read - Reading from keys (values or metadata). Note that commands that don't # interact with keys, will not have either `read` or `write`. # * write - Writing to keys (values or metadata) # * admin - Administrative commands. Normal applications will never need to use # these. Includes REPLICAOF, CONFIG, DEBUG, SAVE, MONITOR, ACL, SHUTDOWN, etc. # * dangerous - Potentially dangerous (each should be considered with care for # various reasons). This includes FLUSHALL, MIGRATE, RESTORE, SORT, KEYS, # CLIENT, DEBUG, INFO, CONFIG, SAVE, REPLICAOF, etc. # * connection - Commands affecting the connection or other connections. # This includes AUTH, SELECT, COMMAND, CLIENT, ECHO, PING, etc. # * blocking - Potentially blocking the connection until released by another # command. # * fast - Fast O(1) commands. May loop on the number of arguments, but not the # number of elements in the key. # * slow - All commands that are not Fast. # * pubsub - PUBLISH / SUBSCRIBE related # * transaction - WATCH / MULTI / EXEC related commands. # * scripting - Scripting related. # * set - Data type: sets related. # * sortedset - Data type: zsets related. # * list - Data type: lists related. # * hash - Data type: hashes related. # * string - Data type: strings related. # * bitmap - Data type: bitmaps related. # * hyperloglog - Data type: hyperloglog related. # * geo - Data type: geo related. # * stream - Data type: streams related. # # For more information about ACL configuration please refer to # the Redis web site at https://redis.io/topics/acl
＃Redis ACL 用户以以下格式定义：＃＃用户<用户名> ... acl 规则...＃＃例如：＃＃用户 worker +@list +@connection ~jobs：* on >ffa9203c493aa99＃＃特殊用户名"default"用于新连接。如果此用户具有"nopass"规则，则新连接将立即作为"default"用户进行身份验证，而无需通过 AUTH 命令提供任何密码。否则，如果"default"用户未标记为"nopass"，则连接将以未经身份验证的状态启动，并且将需要 AUTH（或 HELLO 命令 AUTH 选项）才能进行身份验证并开始工作。＃＃描述用户可以执行的 ACL 规则如下：＃＃on 启用用户：可以作为此用户进行身份验证。＃关闭禁用用户：不再可以使用此用户进行身份验证，但已经经过身份验证的连接仍将工作。＃skip-sanitize-payload RESTORE 跳过 dump-payload 消毒。＃sanitize-payload RESTORE dump-payload 已消毒（默认）。＃+<command>允许执行该命令。＃可以与`|`一起使用以允许子命令（例如。g "+config|get") # -<command> 禁止执行该命令。 # 可以与`|`一起使用来阻止子命令（例如"-config|set"） # +@<category> 允许执行该类别中的所有命令 # 有效的类别如@admin，@set，@sortedset 等等 # 等等，在 server.c 文件中可以看到完整的列表 # Redis 命令表的描述和定义。 # 特殊类别@all 表示所有命令，但目前只存在于服务器中， # 并且将来会通过模块加载。 # +<command>|first-arg 允许特定的第一个参数，否则该命令将被禁用。 # 仅支持没有子命令的命令，并且不允许使用负形式 # 如-SELECT|1，只能使用以“+”开头的添加形式。 # 此功能已被弃用，将来可能会被删除。 # allcommands 是+@all 的别名。请注意，它意味着能够执行 # 通过模块系统加载的所有未来命令。 # nocommands 是-@all 的别名。 # ~<pattern> 添加可以作为命令一部分提及的键的模式。例如，~*允许所有键。 # 模式是类似于 KEYS 的通配符样式模式。 # 可以指定多个模式。# %R〜<模式> 添加键读取模式，指定可以读取的键#。# %W〜<模式> 添加键写入模式，指定可以写入的键#。# allkeys 别名为〜*# resetkeys 清除允许的键模式列表。#＆<模式>添加用户可以访问的 Pub/Sub 频道的 glob 样式模式#。可以指定多个频道模式。# allchannels 别名为＆*# resetchannels 清除允许的频道模式列表。# ><密码>将此密码添加到用户的有效密码列表中。#例如>mypass 将添加“mypass”到列表中。#此指令清除“nopass”标志（稍后见）。# <<密码>从有效密码列表中删除此密码。# nopass 用户的所有设置密码都将被删除，并且用户#被标记为不需要密码：这意味着每个#密码都可以用于此用户。如果使用此指令#用于默认用户，则每个新连接都将#立即使用默认用户进行身份验证，无需#任何明确的 AUTH 命令。请注意，“resetpass”#指令将清除此条件。 # resetpass 清除允许密码列表。此外，删除“nopass”状态。在“resetpass”之后，用户没有关联密码，没有添加密码（或稍后将其设置为“nopass”）的方式进行身份验证。 # reset 执行以下操作：resetpass、resetkeys、resetchannels、allchannels（如果设置了 acl-pubsub-default）、off、clearselectors、-@all。 # 用户返回到创建后立即具有的相同状态。 # （<options>）使用括号中指定的选项创建一个新选择器，并将其附加到用户。每个选项应以空格分隔。第一个字符必须是（，最后一个字符必须是）。 # clearselectors 删除当前附加的所有选择器。 # 请注意，这不会更改“root”用户权限，这些权限直接应用于用户（在括号之外）。 # ACL 规则可以按任何顺序指定：例如，您可以从密码开始，然后是标志或密钥模式。但请注意，根据顺序，加法和减法规则的含义会发生变化。 例如，请参阅以下示例： 用户 alice 在+@all-DEBUG ~* >somepassword 上 这将允许“alice”使用所有命令，但除了 DEBUG 命令之外，因为+@all 向允许“alice”使用的命令集中添加了所有命令，随后又删除了 DEBUG 命令。但是，如果我们倒转两个 ACL 规则的顺序，结果会有所不同： 用户 alice 处于-DEBUG+@all ~* >somepassword 之中 现在在允许命令集中没有命令的情况下删除了 DEBUG 命令，稍后添加了所有命令，因此用户将能够执行所有操作。 基本上 ACL 规则从左到右处理。 以下是命令类别及其含义列表： *键空间-以类型不可知的方式编写或读取键、数据库或其元数据。包括 DEL、RESTORE、DUMP、RENAME、EXISTS、DBSIZE、KEYS、EXPIRE、TTL、FLUSHALL 等。可能修改键空间、键或元数据的命令也将具有“写”类别。而仅读取键空间、键或元数据的命令则具有“读取”类别。 *读取-从键（值或元数据）读取。 请注意，不涉及键的命令将没有`读`或`写`。#*写入-向键（值或元数据）写入#*管理员-管理员命令。一般应用程序将永远不需要使用这些命令。包括 REPLICAOF、CONFIG、DEBUG、SAVE、MONITOR、ACL、SHUTDOWN 等。#*危险-潜在的危险（每个都应谨慎考虑原因而考虑）。这包括 FLUSHALL、MIGRATE、RESTORE、SORT、KEYS、CLIENT、DEBUG、INFO、CONFIG、SAVE、REPLICAOF 等。#*连接-影响连接或其他连接的命令。包括 AUTH、SELECT、COMMAND、CLIENT、ECHO、PING 等。#*阻塞-可能阻塞连接，直到由另一个命令释放。#*快速-O（1）命令。可能会在参数数量上循环，但不会在键中元素数量上循环。#*慢-所有不快的命令。#*发布/订阅相关#*事务-观看/多/执行相关命令。#*脚本-脚本相关。#*设置-数据类型：集相关。#*sortedset-数据类型：zsets 相关。#*列表-数据类型：列表相关。#*哈希-数据类型：哈希相关。 # * string - 数据类型：与字符串相关。 # * bitmap - 数据类型：与位图相关。 # * hyperloglog - 数据类型：与 HyperLogLog 相关。 # * geo - 数据类型：与地理位置相关。 # * stream - 数据类型：与流相关。 # # 有关 ACL 配置的更多信息，请参考 Redis 网站 https://redis。io/topics/acl

# ACL LOG # # The ACL Log tracks failed commands and authentication events associated # with ACLs. The ACL Log is useful to troubleshoot failed commands blocked # by ACLs. The ACL Log is stored in memory. You can reclaim memory with # ACL LOG RESET. Define the maximum entry length of the ACL Log below. acllog-max-len 128
# ACL 日志 # # ACL 日志跟踪与 ACL 相关的失败命令和身份验证事件。 ACL 日志对于排除由 ACL 阻止的失败命令很有用。 ACL 日志存储在内存中。 您可以使用 ACL LOG RESET 来回收内存。在下面定义 ACL 日志的最大条目长度。acllog-max-len 128

# Using an external ACL file # # Instead of configuring users here in this file, it is possible to use # a stand-alone file just listing users. The two methods cannot be mixed: # if you configure users here and at the same time you activate the external # ACL file, the server will refuse to start. # # The format of the external ACL user file is exactly the same as the # format that is used inside redis.conf to describe users. # # aclfile /etc/redis/users.acl
# 使用外部 ACL 文件 # # 不必在此文件中配置用户，可以使用一个单独的仅列出用户的文件。两种方法不可混用： # 如果您在此处配置用户，同时激活了外部# ACL 文件，服务器将拒绝启动。 # 外部 ACL 用户文件的格式与 redis.conf 内用于描述用户的格式完全相同。 # aclfile /etc/redis/users.acl

# IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatibility # layer on top of the new ACL system. The option effect will be just setting # the password for the default user. Clients will still authenticate using # AUTH <password> as usually, or more explicitly with AUTH default <password> # if they follow the new protocol: both will work. # # The requirepass is not compatible with aclfile option and the ACL LOAD # command, these will cause requirepass to be ignored. # # requirepass foobared
# 重要提示：从 Redis 6 开始，“requirepass”只是新 ACL 系统的兼容层。该选项的效果将仅设置默认用户的密码。客户端仍将像往常一样使用 AUTH <password>进行身份验证，或者更明确地使用 AUTH default <password>，如果他们遵循新协议：两者都可以。# # requirepass 与 aclfile 选项和 ACL LOAD 命令不兼容，这将导致 requirepass 被忽略。# # requirepass foobared

# New users are initialized with restrictive permissions by default, via the # equivalent of this ACL rule 'off resetkeys -@all'. Starting with Redis 6.2, it # is possible to manage access to Pub/Sub channels with ACL rules as well. The # default Pub/Sub channels permission if new users is controlled by the # acl-pubsub-default configuration directive, which accepts one of these values: # # allchannels: grants access to all Pub/Sub channels # resetchannels: revokes access to all Pub/Sub channels # # From Redis 7.0, acl-pubsub-default defaults to 'resetchannels' permission. # # acl-pubsub-default resetchannels
# 默认情况下，新用户通过 ACL 规则“off resetkeys -@all”初始化为具有限制权限。 从 Redis 6.2 开始，还可以使用 ACL 规则管理对 Pub/Sub 频道的访问。 新用户的默认 Pub/Sub 频道权限由 acl-pubsub-default 配置指令控制，该指令接受以下值之一： # # allchannels：授予对所有 Pub/Sub 频道的访问权限 # resetchannels：撤销对所有 Pub/Sub 频道的访问权限 # # 从 Redis 7.0 开始，acl-pubsub-default 默认为'resetchannels'权限。 # # acl-pubsub-default resetchannels

# Command renaming (DEPRECATED). # # ------------------------------------------------------------------------ # WARNING: avoid using this option if possible. Instead use ACLs to remove # commands from the default user, and put them only in some admin user you # create for administrative purposes. # ------------------------------------------------------------------------ # # It is possible to change the name of dangerous commands in a shared # environment. For instance the CONFIG command may be renamed into something # hard to guess so that it will still be available for internal-use tools # but not available for general clients. # # Example: # # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 # # It is also possible to completely kill a command by renaming it into # an empty string: # # rename-command CONFIG "" # # Please note that changing the name of commands that are logged into the # AOF file or transmitted to replicas may cause problems.
# 命令重命名（已弃用）。# # ------------------------------------------------------------------------ # 警告：尽量避免使用此选项。而是使用 ACL 来从默认用户中删除命令，并将它们仅放在您为管理目的创建的某个管理员用户中。# ------------------------------------------------------------------------ # # 在共享环境中更改危险命令的名称是可能的。例如，CONFIG 命令可以重命名为难以猜测的内容，以便它仍然可供内部工具使用，但对于普通客户不可用。# # 示例：# # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 # # 还可以通过将命令重命名为空字符串来完全禁用命令：# # rename-command CONFIG "" # # 请注意，更改记录在 AOF 文件或传输到副本中的命令名称可能会导致问题。

################################### CLIENTS ####################################
######################################## 客户 ####################################

# Set the max number of connected clients at the same time. By default # this limit is set to 10000 clients, however if the Redis server is not # able to configure the process file limit to allow for the specified limit # the max number of allowed clients is set to the current file limit # minus 32 (as Redis reserves a few file descriptors for internal uses). # # Once the limit is reached Redis will close all the new connections sending # an error 'max number of clients reached'. # # IMPORTANT: When Redis Cluster is used, the max number of connections is also # shared with the cluster bus: every node in the cluster will use two # connections, one incoming and another outgoing. It is important to size the # limit accordingly in case of very large clusters. # # maxclients 10000
#设置同时连接的最大客户端数。默认情况下，此限制设置为 10000 个客户端，但如果 Redis 服务器无法将进程文件限制配置为允许指定的限制，则允许的客户端最大数量设置为当前文件限制减去 32（因为 Redis 为内部使用保留了一些文件描述符）。 #一旦达到限制，Redis 将关闭发送新连接的所有连接，并发送错误“已达到最大客户端数”。 #重要提示：使用 Redis 集群时，连接的最大数量也与集群总线共享：集群中的每个节点将使用两个连接，一个传入连接和一个传出连接。在非常大的集群情况下，根据需要调整限制非常重要。 #maxclients 10000

############################## MEMORY MANAGEMENT ################################
内存管理

# Set a memory usage limit to the specified amount of bytes. # When the memory limit is reached Redis will try to remove keys # according to the eviction policy selected (see maxmemory-policy). # # If Redis can't remove keys according to the policy, or if the policy is # set to 'noeviction', Redis will start to reply with errors to commands # that would use more memory, like SET, LPUSH, and so on, and will continue # to reply to read-only commands like GET. # # This option is usually useful when using Redis as an LRU or LFU cache, or to # set a hard memory limit for an instance (using the 'noeviction' policy). # # WARNING: If you have replicas attached to an instance with maxmemory on, # the size of the output buffers needed to feed the replicas are subtracted # from the used memory count, so that network problems / resyncs will # not trigger a loop where keys are evicted, and in turn the output # buffer of replicas is full with DELs of keys evicted triggering the deletion # of more keys, and so forth until the database is completely emptied. # # In short... if you have replicas attached it is suggested that you set a lower # limit for maxmemory so that there is some free RAM on the system for replica # output buffers (but this is not needed if the policy is 'noeviction'). # # maxmemory <bytes>
＃将内存使用限制设置为指定的字节数。＃当达到内存限制时，Redis 将尝试根据选择的驱逐策略（请参阅 maxmemory-policy）删除键。＃＃如果 Redis 无法根据策略删除键，或者策略设置为'noeviction'，Redis 将开始以错误回复命令，这些命令将使用更多内存，例如 SET，LPUSH 等，并将继续回复只读命令，例如 GET。＃＃在将 Redis 用作 LRU 或 LFU 缓存时，或者为实例设置硬内存限制（使用'noeviction'策略）时，通常会有用。＃＃警告：如果您将副本附加到启用 maxmemory 的实例上，则用于馈送副本所需的输出缓冲区的大小将从已使用的内存计数中减去，以便网络问题/重新同步不会触发循环，其中键被驱逐，从而副本的输出缓冲区被 DEL 的键填满，从而触发删除更多键，依此类推，直到数据库完全清空。＃＃简而言之... 如果您有副本附加，建议您设置较低的 maxmemory 上限，以便系统上有一些空闲的 RAM 用于副本输出缓冲区（但如果策略是“noeviction”，则不需要这样做）。# # maxmemory <字节>

# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory # is reached. You can select one from the following behaviors: # # volatile-lru -> Evict using approximated LRU, only keys with an expire set. # allkeys-lru -> Evict any key using approximated LRU. # volatile-lfu -> Evict using approximated LFU, only keys with an expire set. # allkeys-lfu -> Evict any key using approximated LFU. # volatile-random -> Remove a random key having an expire set. # allkeys-random -> Remove a random key, any key. # volatile-ttl -> Remove the key with the nearest expire time (minor TTL) # noeviction -> Don't evict anything, just return an error on write operations. # # LRU means Least Recently Used # LFU means Least Frequently Used # # Both LRU, LFU and volatile-ttl are implemented using approximated # randomized algorithms. # # Note: with any of the above policies, when there are no suitable keys for # eviction, Redis will return an error on write operations that require # more memory. These are usually commands that create new keys, add data or # modify existing keys. A few examples are: SET, INCR, HSET, LPUSH, SUNIONSTORE, # SORT (due to the STORE argument), and EXEC (if the transaction includes any # command that requires memory). # # The default is: # # maxmemory-policy noeviction
# MAXMEMORY 策略：当达到 maxmemory 时，Redis 将选择要删除的内容。您可以从以下行为中选择一个： # # volatile-lru -> 使用近似 LRU 进行驱逐，仅适用于设置了过期时间的键。 # allkeys-lru -> 使用近似 LRU 进行驱逐，适用于任何键。 # volatile-lfu -> 使用近似 LFU 进行驱逐，仅适用于设置了过期时间的键。 # allkeys-lfu -> 使用近似 LFU 进行驱逐，适用于任何键。 # volatile-random -> 删除具有过期时间的随机键。 # allkeys-random -> 删除随机键，任何键。 # volatile-ttl -> 删除具有最近到期时间（较小 TTL）的键。 # noeviction -> 不删除任何内容，只在写操作时返回错误。 # # LRU 表示最近最少使用 # LFU 表示最不经常使用 # # LRU、LFU 和 volatile-ttl 都使用近似随机算法实现。 # # 注意：对于上述任何策略，当没有适合的键进行驱逐时，Redis 将在需要更多内存的写操作上返回错误。这通常是创建新键、添加数据或修改现有键的命令。 一些例子包括：SET、INCR、HSET、LPUSH、SUNIONSTORE、# SORT（由于 STORE 参数）和 EXEC（如果事务包括任何需要内存的命令）。＃＃默认值为：＃＃maxmemory-policy noeviction

# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated # algorithms (in order to save memory), so you can tune it for speed or # accuracy. By default Redis will check five keys and pick the one that was # used least recently, you can change the sample size using the following # configuration directive. # # The default of 5 produces good enough results. 10 Approximates very closely # true LRU but costs more CPU. 3 is faster but not very accurate. The maximum # value that can be set is 64. # # maxmemory-samples 5
# LRU，LFU 和最小 TTL 算法都不是精确的算法，而是近似算法（为了节省内存），因此您可以调整它以提高速度或准确性。默认情况下，Redis 将检查五个键，并选择最近最少使用的键。您可以使用以下配置指令更改样本大小。# # 默认值为 5 可以产生足够好的结果。10 可以非常接近真正的 LRU，但会消耗更多的 CPU。3 的速度更快，但不太准确。可以设置的最大值是 64。# # maxmemory-samples 5

# Eviction processing is designed to function well with the default setting. # If there is an unusually large amount of write traffic, this value may need to # be increased. Decreasing this value may reduce latency at the risk of # eviction processing effectiveness # 0 = minimum latency, 10 = default, 100 = process without regard to latency # # maxmemory-eviction-tenacity 10
#逐出处理在默认设置下设计得很好。 #如果写入流量异常大，则可能需要增加此值。减少此值可能会降低延迟，但会增加逐出处理的风险。 # 0 = 最小延迟，10 = 默认值，100 = 不考虑延迟的处理 # # maxmemory-eviction-tenacity 10

# Starting from Redis 5, by default a replica will ignore its maxmemory setting # (unless it is promoted to master after a failover or manually). It means # that the eviction of keys will be just handled by the master, sending the # DEL commands to the replica as keys evict in the master side. # # This behavior ensures that masters and replicas stay consistent, and is usually # what you want, however if your replica is writable, or you want the replica # to have a different memory setting, and you are sure all the writes performed # to the replica are idempotent, then you may change this default (but be sure # to understand what you are doing). # # Note that since the replica by default does not evict, it may end using more # memory than the one set via maxmemory (there are certain buffers that may # be larger on the replica, or data structures may sometimes take more memory # and so forth). So make sure you monitor your replicas and make sure they # have enough memory to never hit a real out-of-memory condition before the # master hits the configured maxmemory setting. # # replica-ignore-maxmemory yes
# 从 Redis 5 开始，默认情况下，副本将忽略其 maxmemory 设置（除非在故障转移后或手动晋升为主节点后）。这意味着键的驱逐将仅由主节点处理，将 DEL 命令发送到副本以在主节点侧进行键的驱逐。# # 这种行为确保主节点和副本保持一致，并且通常是您想要的，但是如果您的副本是可写的，或者您希望副本具有不同的内存设置，并且您确信对副本执行的所有写操作都是幂等的，那么您可以更改此默认设置（但请确保了解您正在做什么）。# # 请注意，默认情况下，副本不会进行驱逐，因此可能会使用比通过 maxmemory 设置的内存更多的内存（副本上可能有某些缓冲区更大，或者数据结构有时可能占用更多内存等）。因此，请确保监视您的副本，并确保它们有足够的内存，以免在主节点达到配置的 maxmemory 设置之前发生真正的内存不足情况。# # replica-ignore-maxmemory yes

# Redis reclaims expired keys in two ways: upon access when those keys are # found to be expired, and also in background, in what is called the # "active expire key". The key space is slowly and interactively scanned # looking for expired keys to reclaim, so that it is possible to free memory # of keys that are expired and will never be accessed again in a short time. # # The default effort of the expire cycle will try to avoid having more than # ten percent of expired keys still in memory, and will try to avoid consuming # more than 25% of total memory and to add latency to the system. However # it is possible to increase the expire "effort" that is normally set to # "1", to a greater value, up to the value "10". At its maximum value the # system will use more CPU, longer cycles (and technically may introduce # more latency), and will tolerate less already expired keys still present # in the system. It's a tradeoff between memory, CPU and latency. # # active-expire-effort 1
# Redis 以两种方式回收过期键：在访问时发现这些键已过期时，以及在后台进行的“主动过期键”中。键空间会被缓慢地交互式扫描，寻找过期键以回收，这样就有可能在短时间内释放已过期且不会再被访问的键的内存。# # 过期周期的默认努力将尝试避免内存中仍有超过 10％的过期键，并尝试避免消耗超过总内存的 25％并给系统增加延迟。但是，可以增加通常设置为“1”的过期“努力”的值，直至值为“10”。在最大值时，系统将使用更多的 CPU，更长的周期（在技术上可能会引入更多延迟），并且将容忍系统中仍存在的已过期键更少。这是内存、CPU 和延迟之间的权衡。# # 主动过期努力 1

############################# LAZY FREEING ####################################
懒惰释放

# Redis has two primitives to delete keys. One is called DEL and is a blocking # deletion of the object. It means that the server stops processing new commands # in order to reclaim all the memory associated with an object in a synchronous # way. If the key deleted is associated with a small object, the time needed # in order to execute the DEL command is very small and comparable to most other # O(1) or O(log_N) commands in Redis. However if the key is associated with an # aggregated value containing millions of elements, the server can block for # a long time (even seconds) in order to complete the operation. # # For the above reasons Redis also offers non blocking deletion primitives # such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and # FLUSHDB commands, in order to reclaim memory in background. Those commands # are executed in constant time. Another thread will incrementally free the # object in the background as fast as possible. # # DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled. # It's up to the design of the application to understand when it is a good # idea to use one or the other. However the Redis server sometimes has to # delete keys or flush the whole database as a side effect of other operations. # Specifically Redis deletes objects independently of a user call in the # following scenarios: # # 1) On eviction, because of the maxmemory and maxmemory policy configurations, # in order to make room for new data, without going over the specified # memory limit. # 2) Because of expire: when a key with an associated time to live (see the # EXPIRE command) must be deleted from memory. # 3) Because of a side effect of a command that stores data on a key that may # already exist. For example the RENAME command may delete the old key # content when it is replaced with another one. Similarly SUNIONSTORE # or SORT with STORE option may delete existing keys. The SET command # itself removes any old content of the specified key in order to replace # it with the specified string. # 4) During replication, when a replica performs a full resynchronization with # its master, the content of the whole database is removed in order to # load the RDB file just transferred. # # In all the above cases the default is to delete objects in a blocking way, # like if DEL was called. However you can configure each case specifically # in order to instead release memory in a non-blocking way like if UNLINK # was called, using the following configuration directives.
# Redis 有两种原语用于删除键。一种称为 DEL，是对象的阻塞删除。这意味着服务器停止处理新命令，以同步方式回收与对象关联的所有内存。如果删除的键与一个小对象关联，执行 DEL 命令所需的时间非常短，与 Redis 中的大多数其他 O(1)或 O(log_N)命令相当。但是，如果键与包含数百万个元素的聚合值相关联，服务器可能会阻塞很长时间（甚至几秒）才能完成操作。出于上述原因，Redis 还提供了非阻塞删除原语，如 UNLINK（非阻塞 DEL）以及 FLUSHALL 和 FLUSHDB 命令的 ASYNC 选项，以在后台回收内存。这些命令在恒定时间内执行。另一个线程将尽可能快地在后台逐步释放对象。DEL、UNLINK 和 FLUSHALL 和 FLUSHDB 的 ASYNC 选项由用户控制。由应用程序的设计来决定何时使用其中之一。 然而，Redis 服务器有时会在执行其他操作的副作用下删除键或清除整个数据库。具体来说，Redis 在以下情况下独立于用户调用而删除对象：1）当满足 maxmemory 和 maxmemory 策略配置时，通过驱逐以便为新数据腾出空间，而不超过指定的内存限制。2）因为过期：当具有关联寿命时间的键（请参阅 EXPIRE 命令）必须从内存中删除时。3）因为存储数据在已存在的键上的命令的副作用。例如，当使用 RENAME 命令替换另一个命令时，可能会删除旧键内容。类似地，SUNIONSTORE 或带有 STORE 选项的 SORT 可能会删除现有键。 SET 命令本身将删除指定键的任何旧内容，以便用指定字符串替换它。4）在复制期间，当副本执行与其主机的完全重新同步时，将删除整个数据库的内容，以便加载刚传输的 RDB 文件。在所有以上情况下，缺省值是以阻塞方式删除对象，就像调用 DEL 一样。 然而，您可以针对每种情况进行特定配置，以便以非阻塞方式释放内存，就像调用 UNLINK 时一样，使用以下配置指令。

lazyfree-lazy-eviction no lazyfree-lazy-expire no lazyfree-lazy-server-del no replica-lazy-flush no
lazyfree-lazy-eviction 不是懒惰的清理；lazyfree-lazy-expire 不是懒惰的过期；lazyfree-lazy-server-del 不是懒惰的服务器删除；replica-lazy-flush 不进行懒惰的刷新

# It is also possible, for the case when to replace the user code DEL calls # with UNLINK calls is not easy, to modify the default behavior of the DEL # command to act exactly like UNLINK, using the following configuration # directive:
# 当无法轻松地用 UNLINK 调用替换用户代码 DEL 调用时，可以修改 DEL 命令的默认行为，使其完全像 UNLINK 一样操作，使用以下配置指令：

lazyfree-lazy-user-del no
懒惰的自由-懒惰的用户-del 不

# FLUSHDB, FLUSHALL, SCRIPT FLUSH and FUNCTION FLUSH support both asynchronous and synchronous # deletion, which can be controlled by passing the [SYNC|ASYNC] flags into the # commands. When neither flag is passed, this directive will be used to determine # if the data should be deleted asynchronously.
# FLUSHDB，FLUSHALL，SCRIPT FLUSH 和 FUNCTION FLUSH 支持同步和异步删除，可以通过在命令中传递[SYNC|ASYNC]标志来控制。如果未传递任何标志，则将使用该指令来确定是否应异步删除数据。

lazyfree-lazy-user-flush no
懒惰的自由-懒惰的用户-刷新无

################################ THREADED I/O #################################
################################ 线程化输入/输出 #################################

# Redis is mostly single threaded, however there are certain threaded # operations such as UNLINK, slow I/O accesses and other things that are # performed on side threads. # # Now it is also possible to handle Redis clients socket reads and writes # in different I/O threads. Since especially writing is so slow, normally # Redis users use pipelining in order to speed up the Redis performances per # core, and spawn multiple instances in order to scale more. Using I/O # threads it is possible to easily speedup two times Redis without resorting # to pipelining nor sharding of the instance. # # By default threading is disabled, we suggest enabling it only in machines # that have at least 4 or more cores, leaving at least one spare core. # Using more than 8 threads is unlikely to help much. We also recommend using # threaded I/O only if you actually have performance problems, with Redis # instances being able to use a quite big percentage of CPU time, otherwise # there is no point in using this feature. # # So for instance if you have a four cores boxes, try to use 2 or 3 I/O # threads, if you have a 8 cores, try to use 6 threads. In order to # enable I/O threads use the following configuration directive: # # io-threads 4 # # Setting io-threads to 1 will just use the main thread as usual. # When I/O threads are enabled, we only use threads for writes, that is # to thread the write(2) syscall and transfer the client buffers to the # socket. However it is also possible to enable threading of reads and # protocol parsing using the following configuration directive, by setting # it to yes: # # io-threads-do-reads no # # Usually threading reads doesn't help much. # # NOTE 1: This configuration directive cannot be changed at runtime via # CONFIG SET. Also, this feature currently does not work when SSL is # enabled. # # NOTE 2: If you want to test the Redis speedup using redis-benchmark, make # sure you also run the benchmark itself in threaded mode, using the # --threads option to match the number of Redis threads, otherwise you'll not # be able to notice the improvements.
# Redis 大多数情况下是单线程的，但是有一些多线程操作，比如 UNLINK、缓慢的 I/O 访问和其他一些在边缘线程上执行的任务。# # 现在还可以在不同的 I/O 线程中处理 Redis 客户端套接字读写。由于特别是写入操作很慢，通常 Redis 用户使用管线技术来加快 Redis 每个核的性能，并产生多个实例以实现更大的扩展。使用 I/O 线程可以轻松地将 Redis 加速两倍，而不必使用管道或实例的分片。# # 默认情况下禁用线程，我们建议仅在具有至少 4 个或更多核心的计算机中启用线程，并留出至少一个备用核心。使用超过 8 个线程不太可能有很大帮助。我们还建议仅在实际存在性能问题时使用线程 I/O，Redis 实例能够使用相当大的 CPU 时间百分比，否则使用此功能没有意义。# # 因此，例如，如果您有一个四核心的盒子，请尝试使用 2 或 3 个 I/O 线程，如果您有 8 个核心，请尝试使用 6 个线程。 为了启用 I/O 线程，请使用以下配置指令：io-threads 4。将 io-threads 设置为 1 将仅使用主线程如常。启用 I/O 线程后，我们仅使用写入线程，即将 write(2)系统调用线程化并将客户端缓冲区传输到套接字。但也可以通过将以下配置指令设置为 yes 来启用读取和协议解析的线程化：io-threads-do-reads no。通常，线程化读取并不会带来太大帮助。注意 1：无法通过 CONFIG SET 在运行时更改此配置指令。此功能在启用 SSL 时目前也无法使用。注意 2：如果要测试 Redis 加速，请确保还以线程模式运行基准测试本身，使用--threads 选项匹配 Redis 线程数，否则您将无法注意到改进。

############################ KERNEL OOM CONTROL ##############################
内核 OOM 控制

# On Linux, it is possible to hint the kernel OOM killer on what processes # should be killed first when out of memory. # # Enabling this feature makes Redis actively control the oom_score_adj value # for all its processes, depending on their role. The default scores will # attempt to have background child processes killed before all others, and # replicas killed before masters. # # Redis supports these options: # # no: Don't make changes to oom-score-adj (default). # yes: Alias to "relative" see below. # absolute: Values in oom-score-adj-values are written as is to the kernel. # relative: Values are used relative to the initial value of oom_score_adj when # the server starts and are then clamped to a range of -1000 to 1000. # Because typically the initial value is 0, they will often match the # absolute values. oom-score-adj no
在 Linux 上，当内存不足时，可以向内核 OOM Killer 提示首先应该杀死哪些进程。启用此功能会使 Redis 积极控制所有其进程的 oom_score_adj 值，取决于它们的角色。默认分数将尝试在所有其他进程之前杀死后台子进程，并在主节点之前杀死副本。Redis 支持以下选项：no：不更改 oom-score-adj（默认值）。yes：别名为“相对”请参阅下文。absolute：oom-score-adj-values 中的值按原样写入内核。relative：在服务器启动时，使用相对于 oom_score_adj 的初始值的值，然后将其夹在-1000 到 1000 的范围内。因为通常初始值为 0，它们经常匹配绝对值。oom-score-adj no

# When oom-score-adj is used, this directive controls the specific values used # for master, replica and background child processes. Values range -2000 to # 2000 (higher means more likely to be killed). # # Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities) # can freely increase their value, but not decrease it below its initial # settings. This means that setting oom-score-adj to "relative" and setting the # oom-score-adj-values to positive values will always succeed. oom-score-adj-values 0 200 800
# 当使用 oom-score-adj 时，此指令控制主进程、副本和后台子进程使用的具体值。值范围为-2000 至 2000（值越高，越有可能被杀死）。 # # 非特权进程（非 root，且没有 CAP_SYS_RESOURCE 权限）可以自由增加其值，但不能将其降低到初始设置以下。 # 这意味着将 oom-score-adj 设置为“相对”，并将 oom-score-adj-values 设置为正值将始终成功。 oom-score-adj-values 0 200 800

#################### KERNEL transparent hugepage CONTROL ######################
#################### 内核透明大页控制 ######################

# Usually the kernel Transparent Huge Pages control is set to "madvise" or # or "never" by default (/sys/kernel/mm/transparent_hugepage/enabled), in which # case this config has no effect. On systems in which it is set to "always", # redis will attempt to disable it specifically for the redis process in order # to avoid latency problems specifically with fork(2) and CoW. # If for some reason you prefer to keep it enabled, you can set this config to # "no" and the kernel global to "always".
#通常，内核透明巨页控制默认设置为“madvise”或#或“never”（/sys/kernel/mm/transparent_hugepage/enabled），在这种情况下，此配置无效。 在设置为“always”的系统上，redis 将尝试专门为 redis 进程禁用它，以避免使用 fork（2）和 CoW 特别存在的延迟问题。 #如果出于某种原因您希望保持其启用状态，则可以将此配置设置为“no”，并将内核全局设置为“always”。

disable-thp yes 禁用 thp 是的

############################## APPEND ONLY MODE ###############################
只追加模式

# By default Redis asynchronously dumps the dataset on disk. This mode is # good enough in many applications, but an issue with the Redis process or # a power outage may result into a few minutes of writes lost (depending on # the configured save points). # # The Append Only File is an alternative persistence mode that provides # much better durability. For instance using the default data fsync policy # (see later in the config file) Redis can lose just one second of writes in a # dramatic event like a server power outage, or a single write if something # wrong with the Redis process itself happens, but the operating system is # still running correctly. # # AOF and RDB persistence can be enabled at the same time without problems. # If the AOF is enabled on startup Redis will load the AOF, that is the file # with the better durability guarantees. # # Note that changing this value in a config file of an existing database and # restarting the server can lead to data loss. A conversion needs to be done # by setting it via CONFIG command on a live server first. # # Please check https://redis.io/topics/persistence for more information.
# 默认情况下，Redis 会异步将数据集转储到磁盘上。在许多应用程序中，该模式已经足够好，但是 Redis 进程的问题或断电可能会导致几分钟的写入丢失（取决于配置的保存点）。# #追加文件是一种替代的持久性模式，提供更好的持久性。例如，使用默认数据 fsync 策略（请参见配置文件中的稍后说明），Redis 在发生戏剧性事件（例如服务器停电）或 Redis 进程本身出现问题，但操作系统仍然运行正确时，可以仅丢失一秒钟的写入。# #可以同时启用 AOF 和 RDB 持久性，没有问题。如果在启动时启用了 AOF，则 Redis 将加载 AOF，即提供更好持久性保证的文件。# #请注意，在现有数据库的配置文件中更改此值并重新启动服务器可能会导致数据丢失。首先通过在活动服务器上 CONFIG 命令设置来进行转换。# #请访问 https://redis.io/topics/persistence 了解更多信息。

appendonly no

# The base name of the append only file. # # Redis 7 and newer use a set of append-only files to persist the dataset # and changes applied to it. There are two basic types of files in use: # # - Base files, which are a snapshot representing the complete state of the # dataset at the time the file was created. Base files can be either in # the form of RDB (binary serialized) or AOF (textual commands). # - Incremental files, which contain additional commands that were applied # to the dataset following the previous file. # # In addition, manifest files are used to track the files and the order in # which they were created and should be applied. # # Append-only file names are created by Redis following a specific pattern. # The file name's prefix is based on the 'appendfilename' configuration # parameter, followed by additional information about the sequence and type. # # For example, if appendfilename is set to appendonly.aof, the following file # names could be derived: # # - appendonly.aof.1.base.rdb as a base file. # - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files. # - appendonly.aof.manifest as a manifest file.
# 附加文件的基本名称。# # Redis 7 及更高版本使用一组附加文件来持久化数据集#和应用于数据集的更改。使用两种基本类型的文件：# # - 基本文件，它们是在创建文件时表示数据集完整状态的快照。基本文件可以是 RDB（二进制序列化）或 AOF（文本命令）的形式。# - 增量文件，包含应用于上一个文件后的数据集的附加命令。# # 此外，清单文件用于跟踪文件及其创建顺序和应用顺序。# # Redis 根据特定模式创建附加文件名称。# 文件名的前缀基于'appendfilename'配置参数，后跟有关序列和类型的其他信息。# # 例如，如果 appendfilename 设置为 appendonly.aof，则可以派生以下文件名：# # - appendonly.aof.1.base.rdb 作为基本文件。# - appendonly.aof.1.incr.aof，appendonly.aof.2.incr.aof 作为增量文件。# - appendonly.aof.manifest 作为清单文件。

appendfilename "appendonly.aof"

# For convenience, Redis stores all persistent append-only files in a dedicated # directory. The name of the directory is determined by the appenddirname # configuration parameter.
为了方便起见，Redis 将所有持久性追加文件存储在一个专用目录中。目录的名称由 appenddirname 配置参数确定。

appenddirname "appendonlydir"
appendonlydir 附加目录名

# The fsync() call tells the Operating System to actually write data on disk # instead of waiting for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP. # # Redis supports three different modes: # # no: don't fsync, just let the OS flush the data when it wants. Faster. # always: fsync after every write to the append only log. Slow, Safest. # everysec: fsync only one time every second. Compromise. # # The default is "everysec", as that's usually the right compromise between # speed and data safety. It's up to you to understand if you can relax this to # "no" that will let the operating system flush the output buffer when # it wants, for better performances (but if you can live with the idea of # some data loss consider the default persistence mode that's snapshotting), # or on the contrary, use "always" that's very slow but a bit safer than # everysec. # # More details please check the following article: # http://antirez.com/post/redis-persistence-demystified.html # # If unsure, use "everysec".
＃ fsync（）调用告诉操作系统实际将数据写入磁盘，而不是等待输出缓冲区中的更多数据。一些操作系统确实会刷新磁盘上的数据，而另一些操作系统只会尽快尝试这样做。＃＃ Redis 支持三种不同的模式：＃＃不：不要 fsync，只是让操作系统在需要时刷新数据。更快。＃总是：在每次写入追加日志后进行 fsync。慢，最安全。＃每秒：每秒只进行一次 fsync。妥协。＃＃默认值为“每秒”，因为通常这是速度和数据安全之间的正确妥协。您可以了解是否可以将其放宽到“不”以便让操作系统在需要时刷新输出缓冲区，以获得更好的性能（但如果您可以接受一些数据丢失的想法，请考虑默认的持久性模式，即快照），或者相反，使用“总是”比每秒慢但比每秒更安全。＃＃更多详细信息，请查看以下文章：＃http://antirez.com/post/redis-persistence-demystified.html＃＃如果不确定，请使用“每秒”。

# appendfsync always appendfsync everysec # appendfsync no
# appendfsync 总是 appendfsync everysec # appendfsync no

# When the AOF fsync policy is set to always or everysec, and a background # saving process (a background save or AOF log background rewriting) is # performing a lot of I/O against the disk, in some Linux configurations # Redis may block too long on the fsync() call. Note that there is no fix for # this currently, as even performing fsync in a different thread will block # our synchronous write(2) call. # # In order to mitigate this problem it's possible to use the following option # that will prevent fsync() from being called in the main process while a # BGSAVE or BGREWRITEAOF is in progress. # # This means that while another child is saving, the durability of Redis is # the same as "appendfsync no". In practical terms, this means that it is # possible to lose up to 30 seconds of log in the worst scenario (with the # default Linux settings). # # If you have latency problems turn this to "yes". Otherwise leave it as # "no" that is the safest pick from the point of view of durability.
＃当 AOF fsync 策略设置为 always 或 everysec 时，并且后台保存进程（后台保存或 AOF 日志后台重写）正在对磁盘执行大量 I/O 时，在某些 Linux 配置中，Redis 可能会在 fsync（）调用上阻塞太长时间。请注意，目前没有解决此问题的方法，因为即使在不同线程中执行 fsync 也会阻塞我们的同步写（2）调用。＃＃为了缓解这个问题，可以使用以下选项，该选项将在 BGSAVE 或 BGREWRITEAOF 正在进行时阻止调用 fsync（）。＃＃这意味着在另一个子进程正在保存时，Redis 的持久性与“appendfsync no”相同。在实际情况下，这意味着在最坏的情况下（使用默认 Linux 设置）可能会丢失多达 30 秒的日志。＃＃如果您遇到延迟问题，请将其更改为“是”。否则，请将其保留为“否”，从持久性的角度来看，这是最安全的选择。

no-appendfsync-on-rewrite no
重写时不附加 fsync 否

# Automatic rewrite of the append only file. # Redis is able to automatically rewrite the log file implicitly calling # BGREWRITEAOF when the AOF log size grows by the specified percentage. # # This is how it works: Redis remembers the size of the AOF file after the # latest rewrite (if no rewrite has happened since the restart, the size of # the AOF at startup is used). # # This base size is compared to the current size. If the current size is # bigger than the specified percentage, the rewrite is triggered. Also # you need to specify a minimal size for the AOF file to be rewritten, this # is useful to avoid rewriting the AOF file even if the percentage increase # is reached but it is still pretty small. # # Specify a percentage of zero in order to disable the automatic AOF # rewrite feature.
# 自动重写 only 文件。#当指定的百分比增长时，Redis 能够隐式调用 BGREWRITEAOF 自动重写日志文件。# #以下是它的工作方式:Redis 记住了 AOF 文件的大小，最新的重写(if 未发生重写，自重新启动时的 AOF 的大小被使用), # #这个基础大小与当前大小进行比较。如果当前大小比指定的百分比大，则触发重写。还需要指定要重写 AOF 文件的最小大小， # #这很有用，以避免重写 AOF 文件，即使达到了百分比增加，但它仍然相当小。# #指定百分之零的百分比以禁用自动 AOF#重写功能。

auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb

# An AOF file may be found to be truncated at the end during the Redis # startup process, when the AOF data gets loaded back into memory. # This may happen when the system where Redis is running # crashes, especially when an ext4 filesystem is mounted without the # data=ordered option (however this can't happen when Redis itself # crashes or aborts but the operating system still works correctly). # # Redis can either exit with an error when this happens, or load as much # data as possible (the default now) and start if the AOF file is found # to be truncated at the end. The following option controls this behavior. # # If aof-load-truncated is set to yes, a truncated AOF file is loaded and # the Redis server starts emitting a log to inform the user of the event. # Otherwise if the option is set to no, the server aborts with an error # and refuses to start. When the option is set to no, the user requires # to fix the AOF file using the "redis-check-aof" utility before to restart # the server. # # Note that if the AOF file will be found to be corrupted in the middle # the server will still exit with an error. This option only applies when # Redis will try to read more data from the AOF file but not enough bytes # will be found. aof-load-truncated yes
# Redis 启动过程中，当 AOF 数据重新加载到内存时，可能会发现 AOF 文件在结尾处被截断。# 这可能发生在运行 Redis 的系统崩溃时，特别是当 ext4 文件系统挂载时未使用 data = ordered 选项时（但是当 Redis 本身崩溃或中止但操作系统仍然正常工作时无法发生）。# # Redis 可以在发生这种情况时退出并报错，也可以尽可能加载数据（现在的默认值）并开始，但如果发现 AOF 文件在结尾处被截断，则无法开始。以下选项控制此行为。# # 如果将 aof-load-truncated 设置为“是”，则会加载截断的 AOF 文件，并且 Redis 服务器会开始发出日志以通知用户发生了事件。# 否则，如果将该选项设置为“否”，服务器将放弃启动并报错。当选项设置为“否”时，用户需要使用“redis-check-aof”实用程序修复 AOF 文件，然后重新启动服务器。# # 请注意，如果发现 AOF 文件在中间被损坏，服务器仍将报错并退出。 此选项仅在# Redis 尝试从 AOF 文件中读取更多数据但找不到足够字节时才适用。aof-load-truncated 是的

# Redis can create append-only base files in either RDB or AOF formats. Using # the RDB format is always faster and more efficient, and disabling it is only # supported for backward compatibility purposes. aof-use-rdb-preamble yes
# Redis 可以以 RDB 或 AOF 格式创建追加式基础文件。使用 RDB 格式始终更快更高效，禁用它仅支持向后兼容性目的。aof-use-rdb-preamble 是的

# Redis supports recording timestamp annotations in the AOF to support restoring # the data from a specific point-in-time. However, using this capability changes # the AOF format in a way that may not be compatible with existing AOF parsers. aof-timestamp-enabled no
# Redis 支持在 AOF 中记录时间戳注释，以支持从特定时间点恢复数据。但是，使用此功能会以一种可能与现有 AOF 解析器不兼容的方式更改 AOF 格式。aof-timestamp-enabled no

################################ SHUTDOWN #####################################
################################ 关闭 #####################################

# Maximum time to wait for replicas when shutting down, in seconds. # # During shut down, a grace period allows any lagging replicas to catch up with # the latest replication offset before the master exists. This period can # prevent data loss, especially for deployments without configured disk backups. # # The 'shutdown-timeout' value is the grace period's duration in seconds. It is # only applicable when the instance has replicas. To disable the feature, set # the value to 0. # # shutdown-timeout 10
# 关闭时等待副本的最长时间，单位为秒。# # 在关闭期间，宽限期允许任何滞后的副本赶上最新的复制偏移量，然后主节点退出。这段时间可以防止数据丢失，特别是对于没有配置磁盘备份的部署。# # 'shutdown-timeout'值是宽限期的持续时间，单位为秒。仅当实例有副本时才适用。要禁用该功能，请将值设置为 0。# # shutdown-timeout 10

# When Redis receives a SIGINT or SIGTERM, shutdown is initiated and by default # an RDB snapshot is written to disk in a blocking operation if save points are configured. # The options used on signaled shutdown can include the following values: # default: Saves RDB snapshot only if save points are configured. # Waits for lagging replicas to catch up. # save: Forces a DB saving operation even if no save points are configured. # nosave: Prevents DB saving operation even if one or more save points are configured. # now: Skips waiting for lagging replicas. # force: Ignores any errors that would normally prevent the server from exiting. # # Any combination of values is allowed as long as "save" and "nosave" are not set simultaneously. # Example: "nosave force now" # # shutdown-on-sigint default # shutdown-on-sigterm default
# 当 Redis 接收到 SIGINT 或 SIGTERM 时，将启动关闭操作，并默认情况下，如果配置了保存点，则会将 RDB 快照写入磁盘，这是一个阻塞操作。 # 信号关闭时使用的选项可以包括以下值： # default：仅在配置了保存点时保存 RDB 快照。 # 等待滞后的副本追赶上。 # save：强制进行 DB 保存操作，即使没有配置保存点。 # nosave：即使配置了一个或多个保存点，也会阻止 DB 保存操作。 # now：跳过等待滞后的副本。 # force：忽略通常会阻止服务器退出的任何错误。 # # 可以允许任意组合的值，只要“save”和“nosave”不同时设置。 # 示例：“nosave force now” # # shutdown-on-sigint default # shutdown-on-sigterm default

################ NON-DETERMINISTIC LONG BLOCKING COMMANDS #####################
################ 不确定性长阻塞命令 #####################

# Maximum time in milliseconds for EVAL scripts, functions and in some cases # modules' commands before Redis can start processing or rejecting other clients. # # If the maximum execution time is reached Redis will start to reply to most # commands with a BUSY error. # # In this state Redis will only allow a handful of commands to be executed. # For instance, SCRIPT KILL, FUNCTION KILL, SHUTDOWN NOSAVE and possibly some # module specific 'allow-busy' commands. # # SCRIPT KILL and FUNCTION KILL will only be able to stop a script that did not # yet call any write commands, so SHUTDOWN NOSAVE may be the only way to stop # the server in the case a write command was already issued by the script when # the user doesn't want to wait for the natural termination of the script. # # The default is 5 seconds. It is possible to set it to 0 or a negative value # to disable this mechanism (uninterrupted execution). Note that in the past # this config had a different name, which is now an alias, so both of these do # the same: # lua-time-limit 5000 # busy-reply-threshold 5000
#EVAL 脚本，函数和一些情况下模块命令的最大执行时间（以毫秒为单位），在 Redis 开始处理或拒绝其他客户端之前。＃ #如果达到了最大执行时间，Redis 将开始用 BUSY 错误回复大多数命令。＃ #在这种状态下，Redis 只允许执行少量命令。例如，SCRIPT KILL，FUNCTION KILL，SHUTDOWN NOSAVE 和可能一些特定于模块的“allow-busy”命令。＃ #SCRIPT KILL 和 FUNCTION KILL 只能停止尚未调用任何写入命令的脚本，因此当用户不想等待脚本的自然终止时，SHUTDOWN NOSAVE 可能是停止服务器的唯一方式，以防脚本已经发布了写入命令。＃ #默认值为 5 秒。可以将其设置为 0 或负值以禁用此机制（不间断执行）。请注意，过去此配置具有不同的名称，现在是别名，因此这两个都是相同的：＃lua-time-limit 5000＃busy-reply-threshold 5000

################################ REDIS CLUSTER ###############################
################################ REDIS 集群 ###############################

# Normal Redis instances can't be part of a Redis Cluster; only nodes that are # started as cluster nodes can. In order to start a Redis instance as a # cluster node enable the cluster support uncommenting the following: # # cluster-enabled yes
# 普通的 Redis 实例不能成为 Redis 集群的一部分；只有作为集群节点启动的节点才能。要将 Redis 实例启动为集群节点，请取消注释以下内容以启用集群支持：# cluster-enabled yes

# Every cluster node has a cluster configuration file. This file is not # intended to be edited by hand. It is created and updated by Redis nodes. # Every Redis Cluster node requires a different cluster configuration file. # Make sure that instances running in the same system do not have # overlapping cluster configuration file names. # # cluster-config-file nodes-6379.conf
# 每个集群节点都有一个集群配置文件。这个文件不打算手动编辑。它是由 Redis 节点创建和更新的。# 每个 Redis 集群节点都需要一个不同的集群配置文件。# 确保在同一系统中运行的实例没有重叠的集群配置文件名称。# # cluster-config-file nodes-6379.conf

# Cluster node timeout is the amount of milliseconds a node must be unreachable # for it to be considered in failure state. # Most other internal time limits are a multiple of the node timeout. # # cluster-node-timeout 15000
# 集群节点超时是指节点在多少毫秒内无法访问时被视为处于故障状态。# 大多数其他内部时间限制是节点超时的倍数。# # 簇节点超时 15000

# The cluster port is the port that the cluster bus will listen for inbound connections on. When set # to the default value, 0, it will be bound to the command port + 10000. Setting this value requires # you to specify the cluster bus port when executing cluster meet. # cluster-port 0
# 集群端口是集群总线将侦听入站连接的端口。当设置为默认值 0 时，它将绑定到命令端口+10000。设置此值需要在执行集群 meet 时指定集群总线端口。# cluster-port 0

# A replica of a failing master will avoid to start a failover if its data # looks too old. # # There is no simple way for a replica to actually have an exact measure of # its "data age", so the following two checks are performed: # # 1) If there are multiple replicas able to failover, they exchange messages # in order to try to give an advantage to the replica with the best # replication offset (more data from the master processed). # Replicas will try to get their rank by offset, and apply to the start # of the failover a delay proportional to their rank. # # 2) Every single replica computes the time of the last interaction with # its master. This can be the last ping or command received (if the master # is still in the "connected" state), or the time that elapsed since the # disconnection with the master (if the replication link is currently down). # If the last interaction is too old, the replica will not try to failover # at all. # # The point "2" can be tuned by user. Specifically a replica will not perform # the failover if, since the last interaction with the master, the time # elapsed is greater than: # # (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period # # So for example if node-timeout is 30 seconds, and the cluster-replica-validity-factor # is 10, and assuming a default repl-ping-replica-period of 10 seconds, the # replica will not try to failover if it was not able to talk with the master # for longer than 310 seconds. # # A large cluster-replica-validity-factor may allow replicas with too old data to failover # a master, while a too small value may prevent the cluster from being able to # elect a replica at all. # # For maximum availability, it is possible to set the cluster-replica-validity-factor # to a value of 0, which means, that replicas will always try to failover the # master regardless of the last time they interacted with the master. # (However they'll always try to apply a delay proportional to their # offset rank). # # Zero is the only value able to guarantee that when all the partitions heal # the cluster will always be able to continue. # # cluster-replica-validity-factor 10
# 如果一个备份主节点的数据看起来太旧，它将避免启动故障转移。 # # 对于一个备份节点来说，实际上没有简单的方法来精确衡量它的“数据年龄”，因此执行以下两个检查： # # 1）如果有多个备份节点能够进行故障转移，它们会交换消息，以尝试给具有最佳复制偏移量（从主节点处理的更多数据）的备份节点提供优势。备份节点将尝试通过偏移量来获取它们的排名，并将与其排名成比例的延迟应用于故障转移的开始。 # # 2）每个单独的备份节点计算与其主节点的最后一次交互的时间。这可以是最后一次 ping 或接收到的命令（如果主节点仍处于“连接”状态），或者是与主节点断开连接后经过的时间（如果复制链接当前已断开）。如果最后一次交互时间太久远，备份节点将根本不会尝试进行故障转移。 # # 用户可以调整“2”点。 具体来说，如果自上次与主节点交互以来经过的时间大于：（节点超时 * 集群副本有效性因子）+ repl-ping-replica-period，那么副本将不会执行故障转移。例如，如果节点超时为 30 秒，集群副本有效性因子为 10，并假设默认的 repl-ping-replica-period 为 10 秒，那么如果副本与主节点无法通信超过 310 秒，副本将不会尝试故障转移。较大的集群副本有效性因子可能会导致具有过时数据的副本故障转移主节点，而较小的值可能会阻止集群能够选举副本。为了最大化可用性，可以将集群副本有效性因子设置为 0，这意味着副本将始终尝试故障转移主节点，而不考虑它们上次与主节点交互的时间。（但它们始终会尝试应用与其偏移等级成比例的延迟）。零是唯一能够保证当所有分区恢复时集群始终能够继续的值。# # cluster-replica-validity-factor 10

# Cluster replicas are able to migrate to orphaned masters, that are masters # that are left without working replicas. This improves the cluster ability # to resist to failures as otherwise an orphaned master can't be failed over # in case of failure if it has no working replicas. # # Replicas migrate to orphaned masters only if there are still at least a # given number of other working replicas for their old master. This number # is the "migration barrier". A migration barrier of 1 means that a replica # will migrate only if there is at least 1 other working replica for its master # and so forth. It usually reflects the number of replicas you want for every # master in your cluster. # # Default is 1 (replicas migrate only if their masters remain with at least # one replica). To disable migration just set it to a very large value or # set cluster-allow-replica-migration to 'no'. # A value of 0 can be set but is useful only for debugging and dangerous # in production. # # cluster-migration-barrier 1
# 集群副本能够迁移到孤立的主节点，即没有工作副本的主节点。这提高了集群抵抗故障的能力，否则，如果孤立的主节点没有工作副本，那么在发生故障时无法进行故障转移。# # 只有在其旧主节点仍然至少有给定数量的其他工作副本时，副本才会迁移到孤立的主节点。这个数字是“迁移障碍”。迁移障碍为 1 意味着副本只有在其主节点至少有 1 个其他工作副本时才会迁移，依此类推。通常反映了您希望在集群中为每个主节点设置的副本数量。# # 默认值为 1（只有在其主节点仍然至少有一个副本时，副本才会迁移）。要禁用迁移，只需将其设置为一个非常大的值，或将 cluster-allow-replica-migration 设置为'no'。# 可以设置为 0，但仅用于调试，在生产中是危险的。# # cluster-migration-barrier 1

# Turning off this option allows to use less automatic cluster configuration. # It both disables migration to orphaned masters and migration from masters # that became empty. # # Default is 'yes' (allow automatic migrations). # # cluster-allow-replica-migration yes
# 关闭此选项可使用较少的自动集群配置。# 它既禁用了向孤立的主节点迁移，也禁用了从变为空的主节点迁移。# # 默认值为'yes'（允许自动迁移）。# # cluster-allow-replica-migration yes

# By default Redis Cluster nodes stop accepting queries if they detect there # is at least a hash slot uncovered (no available node is serving it). # This way if the cluster is partially down (for example a range of hash slots # are no longer covered) all the cluster becomes, eventually, unavailable. # It automatically returns available as soon as all the slots are covered again. # # However sometimes you want the subset of the cluster which is working, # to continue to accept queries for the part of the key space that is still # covered. In order to do so, just set the cluster-require-full-coverage # option to no. # # cluster-require-full-coverage yes
默认情况下，如果 Redis 集群节点检测到至少有一个哈希槽未覆盖（没有可用节点提供服务），则停止接受查询。这样，如果集群部分宕机（例如一系列哈希槽不再被覆盖），最终整个集群将变得不可用。一旦所有槽位再次被覆盖，它会自动恢复可用状态。然而，有时您希望仍在运行的集群子集继续接受仍被覆盖的键空间的查询。为了实现这一点，只需将 cluster-require-full-coverage 选项设置为 no。cluster-require-full-coverage yes

# This option, when set to yes, prevents replicas from trying to failover its # master during master failures. However the replica can still perform a # manual failover, if forced to do so. # # This is useful in different scenarios, especially in the case of multiple # data center operations, where we want one side to never be promoted if not # in the case of a total DC failure. # # cluster-replica-no-failover no
# 当设置为是时，此选项防止副本在主服务器故障期间尝试进行故障切换。 # 然而，如果被迫这样做，副本仍然可以执行手动故障转移。 # # 这在不同的场景中很有用，特别是在多数据中心操作的情况下， # 我们希望一侧永远不会被提升，除非在整个数据中心故障的情况下。 # # 集群副本无故障切换为否

# This option, when set to yes, allows nodes to serve read traffic while the # cluster is in a down state, as long as it believes it owns the slots. # # This is useful for two cases. The first case is for when an application # doesn't require consistency of data during node failures or network partitions. # One example of this is a cache, where as long as the node has the data it # should be able to serve it. # # The second use case is for configurations that don't meet the recommended # three shards but want to enable cluster mode and scale later. A # master outage in a 1 or 2 shard configuration causes a read/write outage to the # entire cluster without this option set, with it set there is only a write outage. # Without a quorum of masters, slot ownership will not change automatically. # # cluster-allow-reads-when-down no
＃当设置为是时，此选项允许节点在集群处于停机状态时提供读取流量，只要它认为自己拥有插槽。＃＃这对两种情况很有用。第一种情况是当应用程序在节点故障或网络分区期间不需要数据一致性时。一个例子是缓存，只要节点有数据，它就应该能够提供数据。＃＃第二种用例是对不符合推荐的三个分片但希望启用集群模式并稍后扩展的配置。在 1 或 2 个分片配置中，主节点故障会导致整个集群的读/写中断，如果没有设置此选项，则只会有写入中断。没有大多数主节点，插槽所有权不会自动更改。＃＃cluster-allow-reads-when-down no

# This option, when set to yes, allows nodes to serve pubsub shard traffic while # the cluster is in a down state, as long as it believes it owns the slots. # # This is useful if the application would like to use the pubsub feature even when # the cluster global stable state is not OK. If the application wants to make sure only # one shard is serving a given channel, this feature should be kept as yes. # # cluster-allow-pubsubshard-when-down yes
# 当设置为是时，允许节点在群集处于关闭状态时服务于 pubsub 分片流量，只要它认为自己拥有插槽。#这是有用的，如果应用程序想要使用 pubsub 功能，即使#群集的全局稳定状态不 OK。如果应用程序想要确保只有一个分片为给定的频道提供服务，则应将此功能保留为"是"。#cluster-allow-pubsubshard-when 下是

# Cluster link send buffer limit is the limit on the memory usage of an individual # cluster bus link's send buffer in bytes. Cluster links would be freed if they exceed # this limit. This is to primarily prevent send buffers from growing unbounded on links # toward slow peers (E.g. PubSub messages being piled up). # This limit is disabled by default. Enable this limit when 'mem_cluster_links' INFO field # and/or 'send-buffer-allocated' entries in the 'CLUSTER LINKS` command output continuously increase. # Minimum limit of 1gb is recommended so that cluster link buffer can fit in at least a single # PubSub message by default. (client-query-buffer-limit default value is 1gb) # # cluster-link-sendbuf-limit 0 # Clusters can configure their announced hostname using this config. This is a common use case for # applications that need to use TLS Server Name Indication (SNI) or dealing with DNS based # routing. By default this value is only shown as additional metadata in the CLUSTER SLOTS # command, but can be changed using 'cluster-preferred-endpoint-type' config. This value is # communicated along the clusterbus to all nodes, setting it to an empty string will remove # the hostname and also propagate the removal. # # cluster-announce-hostname ""
＃集群链接发送缓冲区限制是单个集群总线链接发送缓冲区的内存使用限制（以字节为单位）。如果超过此限制，集群链接将被释放。主要目的是防止发送缓冲区在指向慢对等体的链接上无限增长（例如，PubSub 消息被堆积）。＃默认情况下，此限制已禁用。当“mem_cluster_links”INFO 字段和/或“send-buffer-allocated”条目在“CLUSTER LINKS”命令输出中持续增加时，请启用此限制。建议将最小限制设置为 1GB，以便集群链接缓冲区至少可以容纳单个 PubSub 消息（client-query-buffer-limit 默认值为 1GB）。＃＃cluster-link-sendbuf-limit 0＃集群可以使用此配置配置其宣布的主机名。这是需要使用 TLS 服务器名称指示（SNI）或处理基于 DNS 的路由的应用程序的常见用例。默认情况下，此值仅显示为 CLUSTER SLOTS 命令中的附加元数据，但可以使用“cluster-preferred-endpoint-type”配置进行更改。 此值通过集群总线传递给所有节点，将其设置为空字符串将删除主机名并传播删除。# # cluster-announce-hostname ""

# Clusters can configure an optional nodename to be used in addition to the node ID for # debugging and admin information. This name is broadcasted between nodes, so will be used # in addition to the node ID when reporting cross node events such as node failures. # cluster-announce-human-nodename ""
# 集群可以配置一个可选的节点名称，用于调试和管理信息，除了节点 ID。此名称在节点之间广播，因此在报告跨节点事件（如节点故障）时，将与节点 ID 一起使用。# cluster-announce-human-nodename ""

# Clusters can advertise how clients should connect to them using either their IP address, # a user defined hostname, or by declaring they have no endpoint. Which endpoint is # shown as the preferred endpoint is set by using the cluster-preferred-endpoint-type # config with values 'ip', 'hostname', or 'unknown-endpoint'. This value controls how # the endpoint returned for MOVED/ASKING requests as well as the first field of CLUSTER SLOTS. # If the preferred endpoint type is set to hostname, but no announced hostname is set, a '?' # will be returned instead. # # When a cluster advertises itself as having an unknown endpoint, it's indicating that # the server doesn't know how clients can reach the cluster. This can happen in certain # networking situations where there are multiple possible routes to the node, and the # server doesn't know which one the client took. In this case, the server is expecting # the client to reach out on the same endpoint it used for making the last request, but use # the port provided in the response. # # cluster-preferred-endpoint-type ip
# 集群可以使用 IP 地址、用户定义的主机名或声明没有端点来广告客户端应如何连接它们。哪个端点被显示为首选端点是通过使用 cluster-preferred-endpoint-type 配置设置的，其值为'ip'、'hostname'或'unknown-endpoint'。这个值控制了 MOVED/ASKING 请求返回的端点以及 CLUSTER SLOTS 的第一个字段。如果首选端点类型设置为主机名，但没有声明主机名，则会返回'?'。 #当集群将自己宣传为具有未知的端点时，它表明服务器不知道客户端如何到达集群。在某些网络情况下，有多个可能的路由到节点，并且服务器不知道客户端选择了哪个路由。在这种情况下，服务器期望客户端使用相同的端点进行联系，但使用响应中提供的端口。＃cluster-preferred-endpoint-type ip

# In order to setup your cluster make sure to read the documentation # available at https://redis.io web site.
为了设置您的集群，请确保阅读 https://redis.io 网站提供的文档。

########################## CLUSTER DOCKER/NAT support ########################
集群 DOCKER/NAT 支持

# In certain deployments, Redis Cluster nodes address discovery fails, because # addresses are NAT-ted or because ports are forwarded (the typical case is # Docker and other containers). # # In order to make Redis Cluster working in such environments, a static # configuration where each node knows its public address is needed. The # following four options are used for this scope, and are: # # * cluster-announce-ip # * cluster-announce-port # * cluster-announce-tls-port # * cluster-announce-bus-port # # Each instructs the node about its address, client ports (for connections # without and with TLS) and cluster message bus port. The information is then # published in the header of the bus packets so that other nodes will be able to # correctly map the address of the node publishing the information. # # If tls-cluster is set to yes and cluster-announce-tls-port is omitted or set # to zero, then cluster-announce-port refers to the TLS port. Note also that # cluster-announce-tls-port has no effect if tls-cluster is set to no. # # If the above options are not used, the normal Redis Cluster auto-detection # will be used instead. # # Note that when remapped, the bus port may not be at the fixed offset of # clients port + 10000, so you can specify any port and bus-port depending # on how they get remapped. If the bus-port is not set, a fixed offset of # 10000 will be used as usual. # # Example: # # cluster-announce-ip 10.1.1.5 # cluster-announce-tls-port 6379 # cluster-announce-port 0 # cluster-announce-bus-port 6380
在某些部署中，Redis Cluster 节点地址发现失败，因为地址被 NAT 或端口被转发（典型情况是 Docker 和其他容器）。 为了使 Redis Cluster 在这种环境中工作，需要一个静态配置，其中每个节点都知道自己的公共地址。以下四个选项用于此目的，分别是： * cluster-announce-ip * cluster-announce-port * cluster-announce-tls-port * cluster-announce-bus-port 每个选项都指示节点关于其地址、客户端端口（用于无 TLS 和有 TLS 的连接）和集群消息总线端口。然后，在总线数据包的头部发布这些信息，以便其他节点能够正确映射发布信息的节点的地址。 如果 tls-cluster 设置为 yes，并且 cluster-announce-tls-port 被省略或设置为零，则 cluster-announce-port 指的是 TLS 端口。还要注意，如果 tls-cluster 设置为 no，则 cluster-announce-tls-port 不起作用。 如果未使用上述选项，则将使用正常的 Redis Cluster 自动检测。 请注意，重新映射时，总线端口可能不在客户端端口+10000 的固定偏移量处，因此您可以根据重新映射的方式指定任何端口和总线端口。如果未设置总线端口，则通常将使用固定偏移量 10000。示例：cluster-announce-ip 10.1.1.5＃cluster-announce-tls-port 6379＃cluster-announce-port 0＃cluster-announce-bus-port 6380

################################## SLOW LOG ###################################
################################## 慢日志 ###################################

# The Redis Slow Log is a system to log queries that exceeded a specified # execution time. The execution time does not include the I/O operations # like talking with the client, sending the reply and so forth, # but just the time needed to actually execute the command (this is the only # stage of command execution where the thread is blocked and can not serve # other requests in the meantime). # # You can configure the slow log with two parameters: one tells Redis # what is the execution time, in microseconds, to exceed in order for the # command to get logged, and the other parameter is the length of the # slow log. When a new command is logged the oldest one is removed from the # queue of logged commands.
# Redis 慢日志是一个系统，用于记录超过指定执行时间的查询。执行时间不包括与客户端通信、发送回复等 I/O 操作，而仅包括实际执行命令所需的时间（这是命令执行的唯一阶段，线程在此期间被阻塞，无法为其他请求提供服务）。# # 您可以使用两个参数配置慢日志：一个参数告诉 Redis 要超过多少微秒的执行时间才能记录命令，另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录命令队列中删除。

# The following time is expressed in microseconds, so 1000000 is equivalent # to one second. Note that a negative number disables the slow log, while # a value of zero forces the logging of every command. slowlog-log-slower-than 10000
＃以下时间以微秒表示，因此 1000000 等于一秒。请注意，负数会禁用慢日志，而零值会强制记录每个命令。slowlog-log-slower-than 10000

# There is no limit to this length. Just be aware that it will consume memory. # You can reclaim memory used by the slow log with SLOWLOG RESET. slowlog-max-len 128
＃这个长度没有限制。只需注意它会消耗内存。＃您可以使用 SLOWLOG RESET 重新获取慢日志使用的内存。slowlog-max-len 128

################################ LATENCY MONITOR ##############################
################################ 延迟监控 ##############################

# The Redis latency monitoring subsystem samples different operations # at runtime in order to collect data related to possible sources of # latency of a Redis instance. # # Via the LATENCY command this information is available to the user that can # print graphs and obtain reports. # # The system only logs operations that were performed in a time equal or # greater than the amount of milliseconds specified via the # latency-monitor-threshold configuration directive. When its value is set # to zero, the latency monitor is turned off. # # By default latency monitoring is disabled since it is mostly not needed # if you don't have latency issues, and collecting data has a performance # impact, that while very small, can be measured under big load. Latency # monitoring can easily be enabled at runtime using the command # "CONFIG SET latency-monitor-threshold <milliseconds>" if needed. latency-monitor-threshold 0
# Redis 延迟监控子系统在运行时对不同操作进行采样，以收集与 Redis 实例潜在延迟来源相关的数据。# # 通过 LATENCY 命令，用户可以访问这些信息，打印图表并获取报告。# # 系统仅记录在超过或等于通过 latency-monitor-threshold 配置指令指定的毫秒数执行的操作。当其值设置为零时，延迟监视器将关闭。# # 默认情况下，延迟监控被禁用，因为如果没有延迟问题，则通常不需要，并且收集数据会对性能产生影响，尽管非常小，但在大负载下可以测量。如果需要，可以在运行时轻松启用延迟监控，使用命令“CONFIG SET latency-monitor-threshold <毫秒>”。延迟监控阈值为 0

################################ LATENCY TRACKING ##############################
延迟跟踪

# The Redis extended latency monitoring tracks the per command latencies and enables # exporting the percentile distribution via the INFO latencystats command, # and cumulative latency distributions (histograms) via the LATENCY command. # # By default, the extended latency monitoring is enabled since the overhead # of keeping track of the command latency is very small. # latency-tracking yes
# Redis 扩展延迟监控跟踪每个命令的延迟，并通过 INFO latencystats 命令导出百分位分布，通过 LATENCY 命令导出累积延迟分布（直方图）。 # 默认情况下，扩展延迟监控已启用，因为跟踪命令延迟的开销非常小。 # latency-tracking yes

# By default the exported latency percentiles via the INFO latencystats command # are the p50, p99, and p999. # latency-tracking-info-percentiles 50 99 99.9
# 默认情况下，通过 INFO latencystats 命令导出的延迟百分位数为 p50、p99 和 p999。# latency-tracking-info-percentiles 50 99 99.9

############################# EVENT NOTIFICATION ##############################
############################# 事件通知 ##############################

# Redis can notify Pub/Sub clients about events happening in the key space. # This feature is documented at https://redis.io/topics/notifications # # For instance if keyspace events notification is enabled, and a client # performs a DEL operation on key "foo" stored in the Database 0, two # messages will be published via Pub/Sub: # # PUBLISH __keyspace@0__:foo del # PUBLISH __keyevent@0__:del foo # # It is possible to select the events that Redis will notify among a set # of classes. Every class is identified by a single character: # # K Keyspace events, published with __keyspace@<db>__ prefix. # E Keyevent events, published with __keyevent@<db>__ prefix. # g Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ... # $ String commands # l List commands # s Set commands # h Hash commands # z Sorted set commands # x Expired events (events generated every time a key expires) # e Evicted events (events generated when a key is evicted for maxmemory) # n New key events (Note: not included in the 'A' class) # t Stream commands # d Module key type events # m Key-miss events (Note: It is not included in the 'A' class) # A Alias for g$lshzxetd, so that the "AKE" string means all the events # (Except key-miss events which are excluded from 'A' due to their # unique nature). # # The "notify-keyspace-events" takes as argument a string that is composed # of zero or multiple characters. The empty string means that notifications # are disabled. # # Example: to enable list and generic events, from the point of view of the # event name, use: # # notify-keyspace-events Elg # # Example 2: to get the stream of the expired keys subscribing to channel # name __keyevent@0__:expired use: # # notify-keyspace-events Ex # # By default all notifications are disabled because most users don't need # this feature and the feature has some overhead. Note that if you don't # specify at least one of K or E, no events will be delivered. notify-keyspace-events ""
# Redis 可以通知 Pub/Sub 客户端有关键空间中发生的事件。#此功能在 https://redis.io/topics/notifications 中有文档记录##例如，如果启用了 keyspace 事件通知，并且客户端在数据库 0 中执行了对存储在键“foo”中的 DEL 操作，则将通过 Pub/Sub 发布两条消息：##PUBLISH __keyspace@0__:foo del#PUBLISH __keyevent@0__:del foo##可以选择 Redis 将在一组类别中通知的事件。每个类别由单个字符标识：##K Keyspace 事件，以__keyspace@<db>__前缀发布。#E Keyevent 事件，以__keyevent@<db>__前缀发布。#g 通用命令（非特定类型），如 DEL，EXPIRE，RENAME，... # $ 字符串命令 # l 列表命令 # s 设置命令 # h 哈希命令 # z 有序集合命令 # x 过期事件（每次键过期时生成的事件） # e 驱逐事件（当键因达到最大内存而被驱逐时生成的事件） # n 新键事件（注意：不包括在 'A' 类中） # t 流命令 # d 模块键类型事件 # m 键丢失事件（注意：不包括在 'A' 类中） # A g$lshzxetd 的别名，因此 "AKE" 字符串表示所有事件 # （键丢失事件除外，由于其独特性质而被排除在 'A' 之外）。 # # "notify-keyspace-events" 接受一个由零个或多个字符组成的字符串作为参数。空字符串表示禁用通知。 # # 示例：要启用列表和通用事件，请使用以下事件名称： # # notify-keyspace-events Elg # # 示例 2：要订阅频道名称为 __keyevent@0__:expired 的过期键流，请使用以下命令： # # notify-keyspace-events Ex # # 默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，并且该功能会带来一些开销。 请注意，如果您不指定至少一个 K 或 E，将不会传递任何事件。通知-键空间事件 ""

############################### ADVANCED CONFIG ###############################
############################### 高级配置 ###############################

# Hashes are encoded using a memory efficient data structure when they have a # small number of entries, and the biggest entry does not exceed a given # threshold. These thresholds can be configured using the following directives. hash-max-listpack-entries 512 hash-max-listpack-value 64
# 当哈希表条目数量较少且最大条目不超过给定阈值时，哈希表会使用内存高效的数据结构进行编码。可以使用以下指令配置这些阈值。hash-max-listpack-entries 512 hash-max-listpack-value 64

# Lists are also encoded in a special way to save a lot of space. # The number of entries allowed per internal list node can be specified # as a fixed maximum size or a maximum number of elements. # For a fixed maximum size, use -5 through -1, meaning: # -5: max size: 64 Kb <-- not recommended for normal workloads # -4: max size: 32 Kb <-- not recommended # -3: max size: 16 Kb <-- probably not recommended # -2: max size: 8 Kb <-- good # -1: max size: 4 Kb <-- good # Positive numbers mean store up to _exactly_ that number of elements # per list node. # The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size), # but if your use case is unique, adjust the settings as necessary. list-max-listpack-size -2
# 列表也以特殊方式编码，以节省大量空间。 # 允许每个内部列表节点的条目数可以指定为固定的最大大小或最大元素数量。 # 对于固定的最大大小，请使用-5 到-1，含义如下： # -5：最大大小：64 Kb <-- 不推荐用于正常工作负载 # -4：最大大小：32 Kb <-- 不推荐 # -3：最大大小：16 Kb <-- 可能不推荐 # -2：最大大小：8 Kb <-- 良好 # -1：最大大小：4 Kb <-- 良好 # 正数表示每个列表节点存储_确切_的元素数量 # 性能最高的选项通常是-2（8 Kb 大小）或-1（4 Kb 大小）， # 但如果您的用例是独特的，请根据需要调整设置。 list-max-listpack-size -2

# Lists may also be compressed. # Compress depth is the number of quicklist ziplist nodes from *each* side of # the list to *exclude* from compression. The head and tail of the list # are always uncompressed for fast push/pop operations. Settings are: # 0: disable all list compression # 1: depth 1 means "don't start compressing until after 1 node into the list, # going from either the head or tail" # So: [head]->node->node->...->node->[tail] # [head], [tail] will always be uncompressed; inner nodes will compress. # 2: [head]->[next]->node->node->...->node->[prev]->[tail] # 2 here means: don't compress head or head->next or tail->prev or tail, # but compress all nodes between them. # 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail] # etc. list-compress-depth 0
#列表也可以压缩。#压缩深度是从列表的每一侧排除多少个快速列表压缩节点。列表的头部和尾部始终未压缩，以实现快速推入/弹出操作。设置为：#0：禁用所有压缩#1：深度 1 表示“直到列表中有 1 个节点后才开始压缩，来自头部或尾部”#因此：[头]->节点->节点->...->节点->[尾]# [头]，[尾]始终未压缩；内部节点将进行压缩。#2：[头]->[下一个]->节点->节点->...->节点->[上一个]->[尾]#这里的 2 表示：不要压缩头或头部->下一个或尾部->上一个或尾部，#但压缩它们之间的所有节点。#3：[头]->[下一个]->[下一个]->节点->节点->...->节点->[上一个]->[上一个]->[尾] #等等。列表压缩深度 0

# Sets have a special encoding when a set is composed # of just strings that happen to be integers in radix 10 in the range # of 64 bit signed integers. # The following configuration setting sets the limit in the size of the # set in order to use this special memory saving encoding. set-max-intset-entries 512
# 当集合由恰好是十进制 10 进制范围内的 64 位有符号整数的字符串组成时，集合具有特殊编码。# 以下配置设置了集合的大小限制，以便使用这种特殊的内存节省编码。set-max-intset-entries 512

# Sets containing non-integer values are also encoded using a memory efficient # data structure when they have a small number of entries, and the biggest entry # does not exceed a given threshold. These thresholds can be configured using # the following directives. set-max-listpack-entries 128 set-max-listpack-value 64
当非整数值的集合包含少量实体且最大实体不超过给定阈值时，也可以使用内存有效的数据结构进行编码。这些阈值可以使用以下命令进行配置。set-max-listpack-entries 128 set-max-listpack-value 64

# Similarly to hashes and lists, sorted sets are also specially encoded in # order to save a lot of space. This encoding is only used when the length and # elements of a sorted set are below the following limits: zset-max-listpack-entries 128 zset-max-listpack-value 64
与哈希和列表类似，有序集合也被特殊编码以节省大量空间。仅在有序集合的长度和元素低于以下限制时使用此编码：zset-max-listpack-entries 128 zset-max-listpack-value 64。

# HyperLogLog sparse representation bytes limit. The limit includes the # 16 bytes header. When a HyperLogLog using the sparse representation crosses # this limit, it is converted into the dense representation. # # A value greater than 16000 is totally useless, since at that point the # dense representation is more memory efficient. # # The suggested value is ~ 3000 in order to have the benefits of # the space efficient encoding without slowing down too much PFADD, # which is O(N) with the sparse encoding. The value can be raised to # ~ 10000 when CPU is not a concern, but space is, and the data set is # composed of many HyperLogLogs with cardinality in the 0 - 15000 range. hll-sparse-max-bytes 3000
# HyperLogLog 稀疏表示字节限制。 该限制包括 16 字节的标头。 当使用稀疏表示的 HyperLogLog 越过此限制时，它将转换为密集表示。 # # 大于 16000 的值是完全无用的，因为在那一点上，密集表示更节省内存。 # # 建议的值约为 3000，以便在不使 PFADD 减速太多的情况下获得空间高效编码的好处，使用稀疏编码时，PFADD 的时间复杂度为 O(N)。 当 CPU 不是问题，但空间是问题，并且数据集由许多基数在 0-15000 范围内的 HyperLogLogs 组成时，该值可以提高到约 10000。 hll-sparse-max-bytes 3000

# Streams macro node max size / items. The stream data structure is a radix # tree of big nodes that encode multiple items inside. Using this configuration # it is possible to configure how big a single node can be in bytes, and the # maximum number of items it may contain before switching to a new node when # appending new stream entries. If any of the following settings are set to # zero, the limit is ignored, so for instance it is possible to set just a # max entries limit by setting max-bytes to 0 and max-entries to the desired # value. stream-node-max-bytes 4096 stream-node-max-entries 100
# 流宏节点最大大小/项目。流数据结构是一个编码多个项目的大节点的基数树。使用此配置，可以配置单个节点的最大字节数，以及在附加新的流条目时可以包含的最大项目数。如果以下任何设置设置为零，则限制将被忽略，因此例如，可以通过将 max-bytes 设置为 0 并将 max-entries 设置为所需值来设置仅最大条目限制。stream-node-max-bytes 4096 stream-node-max-entries 100

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in # order to help rehashing the main Redis hash table (the one mapping top-level # keys to values). The hash table implementation Redis uses (see dict.c) # performs a lazy rehashing: the more operation you run into a hash table # that is rehashing, the more rehashing "steps" are performed, so if the # server is idle the rehashing is never complete and some more memory is used # by the hash table. # # The default is to use this millisecond 10 times every second in order to # actively rehash the main dictionaries, freeing memory when possible. # # If unsure: # use "activerehashing no" if you have hard latency requirements and it is # not a good thing in your environment that Redis can reply from time to time # to queries with 2 milliseconds delay. # # use "activerehashing yes" if you don't have such hard requirements but # want to free memory asap when possible. activerehashing yes
# 主动重新哈希每 100 毫秒使用 1 毫秒的 CPU 时间，以帮助重新哈希主 Redis 哈希表（将顶级键映射到值）。Redis 使用的哈希表实现（参见 dict.c）执行延迟重新哈希：您在重新哈希的哈希表中运行的操作越多，执行的重新哈希“步骤”就越多，因此如果服务器处于空闲状态，则重新哈希永远不会完成，并且哈希表会使用更多内存。默认情况下，每秒使用此毫秒 10 次，以主动重新哈希主词典，尽可能释放内存。如果不确定：如果您有严格的延迟要求，并且 Redis 偶尔会以 2 毫秒的延迟回复查询，那么请使用“activerehashing no”。如果您没有这样的严格要求，但希望尽快释放内存，请使用“activerehashing yes”。activerehashing yes

# The client output buffer limits can be used to force disconnection of clients # that are not reading data from the server fast enough for some reason (a # common reason is that a Pub/Sub client can't consume messages as fast as the # publisher can produce them). # # The limit can be set differently for the three different classes of clients: # # normal -> normal clients including MONITOR clients # replica -> replica clients # pubsub -> clients subscribed to at least one pubsub channel or pattern # # The syntax of every client-output-buffer-limit directive is the following: # # client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds> # # A client is immediately disconnected once the hard limit is reached, or if # the soft limit is reached and remains reached for the specified number of # seconds (continuously). # So for instance if the hard limit is 32 megabytes and the soft limit is # 16 megabytes / 10 seconds, the client will get disconnected immediately # if the size of the output buffers reach 32 megabytes, but will also get # disconnected if the client reaches 16 megabytes and continuously overcomes # the limit for 10 seconds. # # By default normal clients are not limited because they don't receive data # without asking (in a push way), but just after a request, so only # asynchronous clients may create a scenario where data is requested faster # than it can read. # # Instead there is a default limit for pubsub and replica clients, since # subscribers and replicas receive data in a push fashion. # # Note that it doesn't make sense to set the replica clients output buffer # limit lower than the repl-backlog-size config (partial sync will succeed # and then replica will get disconnected). # Such a configuration is ignored (the size of repl-backlog-size will be used). # This doesn't have memory consumption implications since the replica client # will share the backlog buffers memory. # # Both the hard or the soft limit can be disabled by setting them to zero. client-output-buffer-limit normal 0 0 0 client-output-buffer-limit replica 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60
客户端输出缓冲区限制可以用于强制断开那些由于某些原因（常见原因是 Pub / Sub 客户端无法像发布者一样快地消费消息）而无法快速从服务器读取数据的客户端。 对于三种不同类别的客户端，可以设置不同的限制： normal->普通客户包括 MONITOR 客户 replica->副本客户端 pubsub->订阅至少一个 Pub / Sub 通道或模式的客户端 每个 client-output-buffer-limit 指令的语法如下： client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds> 一旦达到硬限制或连续达到指定秒数的软限制，客户端立即断开连接。例如，如果硬限制为 32 兆字节，软限制为 16 兆字节/10 秒，则如果输出缓冲区的大小达到 32 兆字节，客户端将立即断开连接，但如果客户端达到 16 兆字节并持续超出 10 秒的限制，则也会断开连接。 默认情况下，普通客户端不受限制，因为它们不会在未经请求时接收数据（以推送方式），而是在请求后立即接收，因此只有异步客户端可能会创建数据请求速度快于读取速度的情况。相反，发布订阅和复制客户端有默认限制，因为订阅者和复制品以推送方式接收数据。请注意，将复制客户端的输出缓冲区限制设置得低于 repl-backlog-size 配置是没有意义的（部分同步将成功，然后复制品将被断开连接）。这样的配置将被忽略（将使用 repl-backlog-size 的大小）。这不会对内存消耗产生影响，因为复制客户端将共享后备缓冲区内存。通过将硬限制或软限制设置为零，可以禁用两者。client-output-buffer-limit normal 0 0 0 client-output-buffer-limit replica 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60

# Client query buffers accumulate new commands. They are limited to a fixed # amount by default in order to avoid that a protocol desynchronization (for # instance due to a bug in the client) will lead to unbound memory usage in # the query buffer. However you can configure it here if you have very special # needs, such as a command with huge argument, or huge multi/exec requests or alike. # # client-query-buffer-limit 1gb
# 客户端查询缓冲区积累新命令。它们默认限制为固定数量，以避免协议失步（例如由于客户端中的错误而导致查询缓冲区的内存使用量不受限制）。但是，如果您有非常特殊的需求，例如具有巨大参数的命令，或巨大的多/exec 请求等，您可以在这里进行配置。# # client-query-buffer-limit 1gb

# In some scenarios client connections can hog up memory leading to OOM # errors or data eviction. To avoid this we can cap the accumulated memory # used by all client connections (all pubsub and normal clients). Once we # reach that limit connections will be dropped by the server freeing up # memory. The server will attempt to drop the connections using the most # memory first. We call this mechanism "client eviction". # # Client eviction is configured using the maxmemory-clients setting as follows: # 0 - client eviction is disabled (default) # # A memory value can be used for the client eviction threshold, # for example: # maxmemory-clients 1g # # A percentage value (between 1% and 100%) means the client eviction threshold # is based on a percentage of the maxmemory setting. For example to set client # eviction at 5% of maxmemory: # maxmemory-clients 5%
在某些情况下，客户端连接可能会占用内存，导致 OOM 错误或数据驱逐。为了避免这种情况，我们可以限制所有客户端连接（所有 pubsub 和普通客户端）使用的累计内存。一旦我们达到了这个限制，服务器将删除连接以释放内存。服务器将尝试首先使用最多内存的方式来删除连接。我们称这种机制为“客户端驱逐”。 可以使用 maxmemory-clients 设置来配置客户端驱逐，如下所示： 0-禁用客户端驱逐（默认设置） 可以使用内存值作为客户端驱逐阈值，例如： maxmemory-clients 1g 百分比值（在 1％和 100％之间）表示客户端驱逐阈值基于 maxmemory 设置的百分比。例如，要将客户端驱逐设置为最大内存的 5％： maxmemory-clients 5%

# In the Redis protocol, bulk requests, that are, elements representing single # strings, are normally limited to 512 mb. However you can change this limit # here, but must be 1mb or greater # # proto-max-bulk-len 512mb
# 在 Redis 协议中，通常将表示单个字符串的元素的批量请求限制为 512 mb。但是您可以在此更改此限制，但必须为 1mb 或更大 # # proto-max-bulk-len 512mb

# Redis calls an internal function to perform many background tasks, like # closing connections of clients in timeout, purging expired keys that are # never requested, and so forth. # # Not all tasks are performed with the same frequency, but Redis checks for # tasks to perform according to the specified "hz" value. # # By default "hz" is set to 10. Raising the value will use more CPU when # Redis is idle, but at the same time will make Redis more responsive when # there are many keys expiring at the same time, and timeouts may be # handled with more precision. # # The range is between 1 and 500, however a value over 100 is usually not # a good idea. Most users should use the default of 10 and raise this up to # 100 only in environments where very low latency is required. hz 10
# Redis 调用内部函数执行许多后台任务，比如关闭超时客户端的连接，清除从未请求的过期键等。 # # 并非所有任务都以相同的频率执行，但 Redis 会根据指定的“hz”值检查要执行的任务。 # # 默认情况下，“hz”设置为 10。提高该值会在 Redis 空闲时使用更多 CPU，但同时会使 Redis 在有许多键同时过期时更具响应性，并且超时可能会更精确处理。 # # 范围在 1 到 500 之间，但通常不建议超过 100。大多数用户应该使用默认值 10，并仅在需要非常低延迟的环境中将其提高到 100。 hz 10

# Normally it is useful to have an HZ value which is proportional to the # number of clients connected. This is useful in order, for instance, to # avoid too many clients are processed for each background task invocation # in order to avoid latency spikes. # # Since the default HZ value by default is conservatively set to 10, Redis # offers, and enables by default, the ability to use an adaptive HZ value # which will temporarily raise when there are many connected clients. # # When dynamic HZ is enabled, the actual configured HZ will be used # as a baseline, but multiples of the configured HZ value will be actually # used as needed once more clients are connected. In this way an idle # instance will use very little CPU time while a busy instance will be # more responsive. dynamic-hz yes
# 通常，拥有与连接的客户端数量成比例的 HZ 值是有用的。例如，为了避免每个后台任务调用处理过多的客户端，以避免延迟峰值。# # 由于默认情况下默认的 HZ 值保守地设置为 10，Redis 提供并默认启用了使用自适应 HZ 值的能力，当有许多连接的客户端时，将临时提高 HZ 值。# # 启用动态 HZ 后，实际配置的 HZ 将被用作基线，但一旦连接更多客户端，将根据需要实际使用配置的 HZ 值的倍数。这样，空闲实例将使用非常少的 CPU 时间，而繁忙实例将更具响应性。dynamic-hz yes

# When a child rewrites the AOF file, if the following option is enabled # the file will be fsync-ed every 4 MB of data generated. This is useful # in order to commit the file to the disk more incrementally and avoid # big latency spikes. aof-rewrite-incremental-fsync yes
# 当一个孩子重新写入 AOF 文件时，如果启用了以下选项，# 每生成 4 MB 的数据时文件将被 fsync 同步。这是有用的# 为了更增量地将文件提交到磁盘并避免# 大的延迟峰值。aof-rewrite-incremental-fsync yes

# When redis saves RDB file, if the following option is enabled # the file will be fsync-ed every 4 MB of data generated. This is useful # in order to commit the file to the disk more incrementally and avoid # big latency spikes. rdb-save-incremental-fsync yes
# 当 Redis 保存 RDB 文件时，如果启用了以下选项，# 每生成 4 MB 的数据时文件将被 fsync-ed。这对于逐步将文件提交到磁盘并避免大的延迟峰值是有用的。rdb-save-incremental-fsync yes

# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good # idea to start with the default settings and only change them after investigating # how to improve the performances and how the keys LFU change over time, which # is possible to inspect via the OBJECT FREQ command. # # There are two tunable parameters in the Redis LFU implementation: the # counter logarithm factor and the counter decay time. It is important to # understand what the two parameters mean before changing them. # # The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis # uses a probabilistic increment with logarithmic behavior. Given the value # of the old counter, when a key is accessed, the counter is incremented in # this way: # # 1. A random number R between 0 and 1 is extracted. # 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1). # 3. The counter is incremented only if R < P. # # The default lfu-log-factor is 10. This is a table of how the frequency # counter changes with a different number of accesses with different # logarithmic factors: # # +--------+------------+------------+------------+------------+------------+ # | factor | 100 hits | 1000 hits | 100K hits | 1M hits | 10M hits | # +--------+------------+------------+------------+------------+------------+ # | 0 | 104 | 255 | 255 | 255 | 255 | # +--------+------------+------------+------------+------------+------------+ # | 1 | 18 | 49 | 255 | 255 | 255 | # +--------+------------+------------+------------+------------+------------+ # | 10 | 10 | 18 | 142 | 255 | 255 | # +--------+------------+------------+------------+------------+------------+ # | 100 | 8 | 11 | 49 | 143 | 255 | # +--------+------------+------------+------------+------------+------------+ # # NOTE: The above table was obtained by running the following commands: # # redis-benchmark -n 1000000 incr foo # redis-cli object freq foo # # NOTE 2: The counter initial value is 5 in order to give new objects a chance # to accumulate hits. # # The counter decay time is the time, in minutes, that must elapse in order # for the key counter to be decremented. # # The default value for the lfu-decay-time is 1. A special value of 0 means we # will never decay the counter. # # lfu-log-factor 10 # lfu-decay-time 1
# Redis LFU 驱逐（请参阅 maxmemory 设置）可以进行调整。但是，最好从默认设置开始，只有在调查如何改善性能以及键 LFU 随时间变化的情况后才更改它们，可以通过 OBJECT FREQ 命令进行检查。# # Redis LFU 实现中有两个可调参数：计数器对数因子和计数器衰减时间。在更改它们之前，重要的是了解这两个参数的含义。# # LFU 计数器仅为每个键的 8 位，其最大值为 255，因此 Redis 使用具有对数行为的概率增量。给定旧计数器的值，当访问键时，计数器以这种方式递增：# # 1. 从 0 到 1 之间提取一个随机数 R。# 2. 计算概率 P 为 1/（old_value * lfu_log_factor + 1）。# 3. 仅当 R < P 时才递增计数器。# # 默认的 lfu-log-factor 为 10。 这是一张表格，显示了具有不同对数因子并具有不同访问数量的频率#计数器如何变化： +--------+------------+------------+------------+------------+------------+ | 因子 | 100 次 | 1000 次 | 100K 次 | 1M 次 | 10M 次 | +--------+------------+------------+------------+------------+------------+ | 0 | 104 | 255 | 255 | 255 | 255 | +--------+------------+------------+------------+------------+------------+ | 1 | 18 | 49 | 255 | 255 | 255 | +--------+------------+------------+------------+------------+------------+ | 10 | 10 | 18 | 142 | 255 | 255 | +--------+------------+------------+------------+------------+------------+ | 100 | 8 | 11 | 49 | 143 | 255 | +--------+------------+------------+------------+------------+------------+ 注意：上表是通过运行以下命令获得的: redis-benchmark -n 1000000 incr foo redis-cli object freq foo 注意 2：计数器初始值为 5，以便新对象有机会积累点击次数。 计数器衰减时间是减少键计数器所需的时间（以分钟为单位）。 # # lfu-decay-time 的默认值为 1。0 的特殊值表示我们永远不会衰减计数器。# # lfu-log-factor 10 # lfu-decay-time 1

# The maximum number of new client connections accepted per event-loop cycle. This configuration # is set independently for TLS connections. # # By default, up to 10 new connection will be accepted per event-loop cycle for normal connections # and up to 1 new connection per event-loop cycle for TLS connections. # # Adjusting this to a larger number can slightly improve efficiency for new connections # at the risk of causing timeouts for regular commands on established connections. It is # not advised to change this without ensuring that all clients have limited connection # pools and exponential backoff in the case of command/connection timeouts. # # If your application is establishing a large number of new connections per second you should # also consider tuning the value of tcp-backlog, which allows the kernel to buffer more # pending connections before dropping or rejecting connections. # # max-new-connections-per-cycle 10 # max-new-tls-connections-per-cycle 1
#每个事件循环周期可接受的新客户端连接的最大数量。 该配置 #独立设置用于 TLS 连接。 # #默认情况下，每个事件循环周期可接受 10 个新连接用于普通连接 #和每个事件循环周期可接受 1 个新连接用于 TLS 连接。 # #将此调整为较大的数字可以稍微提高新连接的效率 #有导致已建立连接上的常规命令超时的风险。 它是 #不建议更改此设置，而不确保所有客户端都具有有限的连接 #在命令/连接超时的情况下具有指数退避。 # #如果您的应用程序每秒建立大量新连接，则应 #还应考虑调整 tcp-backlog 的值，该值允许内核缓冲更多#沉积连接之前删除或拒绝连接。 # # max-new-connections-per-cycle 10 # max-new-tls-connections-per-cycle 1

########################### ACTIVE DEFRAGMENTATION ####################### # # What is active defragmentation? # ------------------------------- # # Active (online) defragmentation allows a Redis server to compact the # spaces left between small allocations and deallocations of data in memory, # thus allowing to reclaim back memory. # # Fragmentation is a natural process that happens with every allocator (but # less so with Jemalloc, fortunately) and certain workloads. Normally a server # restart is needed in order to lower the fragmentation, or at least to flush # away all the data and create it again. However thanks to this feature # implemented by Oran Agra for Redis 4.0 this process can happen at runtime # in a "hot" way, while the server is running. # # Basically when the fragmentation is over a certain level (see the # configuration options below) Redis will start to create new copies of the # values in contiguous memory regions by exploiting certain specific Jemalloc # features (in order to understand if an allocation is causing fragmentation # and to allocate it in a better place), and at the same time, will release the # old copies of the data. This process, repeated incrementally for all the keys # will cause the fragmentation to drop back to normal values. # # Important things to understand: # # 1. This feature is disabled by default, and only works if you compiled Redis # to use the copy of Jemalloc we ship with the source code of Redis. # This is the default with Linux builds. # # 2. You never need to enable this feature if you don't have fragmentation # issues. # # 3. Once you experience fragmentation, you can enable this feature when # needed with the command "CONFIG SET activedefrag yes". # # The configuration parameters are able to fine tune the behavior of the # defragmentation process. If you are not sure about what they mean it is # a good idea to leave the defaults untouched.
活跃的碎片整理是什么？ 活跃（在线）的碎片整理允许 Redis 服务器压缩内存中小的分配和释放数据之间的空间，从而可以回收内存。 分段是每个分配器（但很少使用 Jemalloc）和某些工作负载都会发生的自然过程。通常需要重新启动服务器以降低碎片化或至少刷新所有数据并重新创建它。然而，由于 Oran Agra 为 Redis 4.0 实现的此功能，在运行时可以以“热”方式发生该过程。 基本上，当碎片化超过一定水平（参见下面的配置选项）时，Redis 将开始在连续的内存区域中创建值的新副本，通过利用某些特定的 Jemalloc 特性（以了解是否分配正在导致碎片化并将其分配在更好的位置），同时释放旧副本的数据。 这个过程会逐步重复应用于所有的键，从而使碎片化降至正常值。 重要的事情要明白： 1. 这个功能默认是禁用的，只有在编译 Redis 时使用我们提供的 Jemalloc 源代码副本时才有效。这是 Linux 版本的默认设置。 2. 如果没有碎片化问题，你不需要启用这个功能。 3. 一旦出现碎片化问题，你可以使用命令"CONFIG SET activedefrag yes"来启用这个功能。 配置参数可以对碎片整理过程的行为进行微调。如果你不确定它们的含义，最好保持默认设置不变。

# Active defragmentation is disabled by default # activedefrag no
# 默认情况下禁用主动碎片整理 # activedefrag no

# Minimum amount of fragmentation waste to start active defrag # active-defrag-ignore-bytes 100mb
# 启动主动碎片整理所需的最小碎片化废物量 # active-defrag-ignore-bytes 100mb

# Minimum percentage of fragmentation to start active defrag # active-defrag-threshold-lower 10
# 开始主动碎片整理的最低碎片百分比 # active-defrag-threshold-lower 10

# Maximum percentage of fragmentation at which we use maximum effort # active-defrag-threshold-upper 100
# 我们使用最大努力的最大碎片化百分比 # active-defrag-threshold-upper 100

# Minimal effort for defrag in CPU percentage, to be used when the lower # threshold is reached # active-defrag-cycle-min 1
# 在 CPU 百分比中达到较低阈值时使用的最小努力进行碎片整理 # active-defrag-cycle-min 1

# Maximal effort for defrag in CPU percentage, to be used when the upper # threshold is reached # active-defrag-cycle-max 25
# 当达到上限阈值时，用于 CPU 百分比中的最大努力整理# active-defrag-cycle-max 25

# Maximum number of set/hash/zset/list fields that will be processed from # the main dictionary scan # active-defrag-max-scan-fields 1000
# 从主词典扫描中处理的集合/哈希/有序集/列表字段的最大数量 # active-defrag-max-scan-fields 1000

# Jemalloc background thread for purging will be enabled by default jemalloc-bg-thread yes
# Jemalloc 后台线程清理将默认启用 jemalloc-bg-thread yes

# It is possible to pin different threads and processes of Redis to specific # CPUs in your system, in order to maximize the performances of the server. # This is useful both in order to pin different Redis threads in different # CPUs, but also in order to make sure that multiple Redis instances running # in the same host will be pinned to different CPUs. # # Normally you can do this using the "taskset" command, however it is also # possible to this via Redis configuration directly, both in Linux and FreeBSD. # # You can pin the server/IO threads, bio threads, aof rewrite child process, and # the bgsave child process. The syntax to specify the cpu list is the same as # the taskset command: # # Set redis server/io threads to cpu affinity 0,2,4,6: # server-cpulist 0-7:2 # # Set bio threads to cpu affinity 1,3: # bio-cpulist 1,3 # # Set aof rewrite child process to cpu affinity 8,9,10,11: # aof-rewrite-cpulist 8-11 # # Set bgsave child process to cpu affinity 1,10,11 # bgsave-cpulist 1,10-11
# 可以将 Redis 的不同线程和进程钉在系统特定的 CPU 上，以最大化服务器的性能。 # 这对于在不同的 CPU 中固定不同的 Redis 线程以及确保运行在同一主机上的多个 Redis 实例被固定在不同的 CPU 中都非常有用。 # # 通常可以使用“taskset”命令来完成这项任务，但在 Linux 和 FreeBSD 中也可以直接通过 Redis 配置来完成。 # # 可以钉住服务器/IO 线程、bio 线程、aof 重写子进程和 bgsave 子进程。指定 CPU 列表的语法与 taskset 命令相同： # # 将 redis 服务器/IO 线程设置为 CPU 亲和力 0、2、4、6： # server-cpulist 0-7:2 # # 将 bio 线程设置为 CPU 亲和力 1、3： # bio-cpulist 1,3 # # 将 aof 重写子进程设置为 CPU 亲和力 8、9、10、11： # aof-rewrite-cpulist 8-11 # # 将 bgsave 子进程设置为 CPU 亲和力 1、10、11 # bgsave-cpulist 1、10-11

# In some cases redis will emit warnings and even refuse to start if it detects # that the system is in bad state, it is possible to suppress these warnings # by setting the following config which takes a space delimited list of warnings # to suppress # # ignore-warnings ARM64-COW-BUG
在某些情况下，如果检测到系统处于糟糕状态，Redis 将发出警告甚至拒绝启动，可以通过设置以下配置来抑制这些警告，该配置接受一个以空格分隔的要抑制的警告列表。忽略警告 ARM64-COW-BUG